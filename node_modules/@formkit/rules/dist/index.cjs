'use strict';

var utils = require('@formkit/utils');

/**
 * Determine if the given input's value was should be considered "accepted".
 * @param context - The FormKitValidationContext
 * @public
 */
const accepted = function accepted({ value }) {
    return ['yes', 'on', '1', 1, true, 'true'].includes(value);
};
accepted.skipEmpty = false;

/**
 * Determine if the given input's value is after a given date.
 * Defaults to current time.
 * @param context - The FormKitValidationContext
 * @public
 */
const date_after = function ({ value }, compare = false) {
    const timestamp = Date.parse(compare || new Date());
    const fieldValue = Date.parse(String(value));
    return isNaN(fieldValue) ? false : fieldValue > timestamp;
};

/**
 * Determine if the given input's value contains only alpha characters.
 * @param context - The FormKitValidationContext
 * @public
 */
const alpha = function ({ value }, set = 'default') {
    const sets = {
        default: /^\p{L}+$/u,
        latin: /^[a-z]+$/i,
    };
    const selectedSet = utils.has(sets, set) ? set : 'default';
    return sets[selectedSet].test(String(value));
};

/**
 * Determine if the given input's value contains only alpha characters or space.
 * @param context - The FormKitValidationContext
 * @public
 */
const alpha_spaces = function ({ value }, set = 'default') {
    const sets = {
        default: /^[\p{L} ]+$/u,
        latin: /^[a-z ]+$/i,
    };
    const selectedSet = utils.has(sets, set) ? set : 'default';
    return sets[selectedSet].test(String(value));
};

/**
 * Determine if the given input's value contains only alpha or numeric characters.
 * @param context - The FormKitValidationContext
 * @public
 */
const alphanumeric = function ({ value }, set = 'default') {
    const sets = {
        default: /^[0-9\p{L}]+$/u,
        latin: /^[0-9a-z]+$/i,
    };
    const selectedSet = utils.has(sets, set) ? set : 'default';
    return sets[selectedSet].test(String(value));
};

/**
 * Determine if the given input's value is before a given date.
 * @param context - The FormKitValidationContext
 * @public
 */
const date_before = function ({ value }, compare = false) {
    const timestamp = Date.parse(compare || new Date());
    const fieldValue = Date.parse(String(value));
    return isNaN(fieldValue) ? false : fieldValue < timestamp;
};

/**
 * Determine if the given input's value is between two other values.
 * @param context - The FormKitValidationContext
 * @public
 */
const between = function between({ value }, from, to) {
    if (!isNaN(value) && !isNaN(from) && !isNaN(to)) {
        const val = 1 * value;
        from = Number(from);
        to = Number(to);
        const [a, b] = from <= to ? [from, to] : [to, from];
        return val >= 1 * a && val <= 1 * b;
    }
    return false;
};

const hasConfirm = /(_confirm(?:ed)?)$/;
/**
 * Determine if the given input's value matches another input's value.
 * @param context - The FormKitValidationContext
 * @public
 */
const confirm = function confirm(node, address, comparison = 'loose') {
    var _a;
    if (!address) {
        address = hasConfirm.test(node.name)
            ? node.name.replace(hasConfirm, '')
            : `${node.name}_confirm`;
    }
    const foreignValue = (_a = node.at(address)) === null || _a === void 0 ? void 0 : _a.value;
    return comparison === 'strict'
        ? node.value === foreignValue
        : node.value == foreignValue;
};

/**
 * Determine if the given input's value contains alpha characters.
 * @param context - The FormKitValidationContext
 * @public
 */
const contains_alpha = function ({ value }, set = 'default') {
    const sets = {
        default: /\p{L}/u,
        latin: /[a-z]/i,
    };
    const selectedSet = utils.has(sets, set) ? set : 'default';
    return sets[selectedSet].test(String(value));
};

/**
 * Determine if the given input's value contains alpha characters or space.
 * @param context - The FormKitValidationContext
 * @public
 */
const contains_alpha_spaces = function ({ value }, set = 'default') {
    const sets = {
        default: /[\p{L} ]/u,
        latin: /[a-z ]/i,
    };
    const selectedSet = utils.has(sets, set) ? set : 'default';
    return sets[selectedSet].test(String(value));
};

/**
 * Determine if the given input's value contains alpha or numeric characters.
 * @param context - The FormKitValidationContext
 * @public
 */
const contains_alphanumeric = function ({ value }, set = 'default') {
    const sets = {
        default: /[0-9\p{L}]/u,
        latin: /[0-9a-z]/i,
    };
    const selectedSet = utils.has(sets, set) ? set : 'default';
    return sets[selectedSet].test(String(value));
};

/**
 * Determine if the given input's value contains lowercase characters.
 * @param context - The FormKitValidationContext
 * @public
 */
const contains_lowercase = function ({ value }, set = 'default') {
    const sets = {
        default: /\p{Ll}/u,
        latin: /[a-z]/,
    };
    const selectedSet = utils.has(sets, set) ? set : 'default';
    return sets[selectedSet].test(String(value));
};

/**
 * Determine if the given input's value contains numeric characters.
 * @param context - The FormKitValidationContext
 * @public
 */
const contains_numeric = function number({ value }) {
    return /[0-9]/.test(String(value));
};

/**
 * Determine if the given input's value contains symbol characters.
 * @param context - The FormKitValidationContext
 * @public
 */
const contains_symbol = function ({ value }) {
    return /[!-/:-@[-`{-~]/.test(String(value));
};

/**
 * Determine if the given input's value contains uppercase characters.
 * @param context - The FormKitValidationContext
 * @public
 */
const contains_uppercase = function ({ value }, set = 'default') {
    const sets = {
        default: /\p{Lu}/u,
        latin: /[A-Z]/,
    };
    const selectedSet = utils.has(sets, set) ? set : 'default';
    return sets[selectedSet].test(String(value));
};

/**
 * Determine if the given input's value is between two other dates.
 * @param context - The FormKitValidationContext
 * @public
 */
const date_between = function date_between({ value }, dateA, dateB) {
    dateA = dateA instanceof Date ? dateA.getTime() : Date.parse(dateA);
    dateB = dateB instanceof Date ? dateB.getTime() : Date.parse(dateB);
    const compareTo = value instanceof Date ? value.getTime() : Date.parse(String(value));
    if (dateA && !dateB) {
        dateB = dateA;
        dateA = Date.now();
    }
    else if (!dateA || !compareTo) {
        return false;
    }
    return compareTo >= dateA && compareTo <= dateB;
};

/**
 * Determine if the given input's value matches a specified date format.
 * @param context - The FormKitValidationContext
 * @public
 */
const date_format = function date({ value }, format) {
    if (format && typeof format === 'string') {
        return utils.regexForFormat(format).test(String(value));
    }
    return !isNaN(Date.parse(String(value)));
};

/**
 * Determine if the given input's value is a plausible email address.
 * @param context - The FormKitValidationContext
 * @public
 */
const email = function email({ value }) {
    const isEmail = /^(([^<>()\[\]\.,;:\s@\"]+(\.[^<>()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
    return isEmail.test(String(value));
};

/**
 * Determine if the given input's value ends with a given string.
 * @param context - The FormKitValidationContext
 * @public
 */
const ends_with = function ends_with({ value }, ...stack) {
    if (typeof value === 'string' && stack.length) {
        return stack.some((item) => {
            return value.endsWith(item);
        });
    }
    else if (typeof value === 'string' && stack.length === 0) {
        return true;
    }
    return false;
};

/**
 * Determine if the given input's value is in a set of possible values.
 * @param context - The FormKitValidationContext
 * @public
 */
const is = function is({ value }, ...stack) {
    return stack.some((item) => {
        if (typeof item === 'object') {
            return utils.eq(item, value);
        }
        return item == value;
    });
};

/**
 * Determine if the given input's value length is full width.
 * @param context - The FormKitValidationContext
 * @public
 */
const length = function length({ value }, first = 0, second = Infinity) {
    first = parseInt(first);
    second = isNaN(parseInt(second)) ? Infinity : parseInt(second);
    const min = first <= second ? first : second;
    const max = second >= first ? second : first;
    if (typeof value === 'string' || Array.isArray(value)) {
        return value.length >= min && value.length <= max;
    }
    else if (value && typeof value === 'object') {
        const length = Object.keys(value).length;
        return length >= min && length <= max;
    }
    return false;
};

/**
 * Determine if the given input's value contains only lowercase characters.
 * @param context - The FormKitValidationContext
 * @public
 */
const lowercase = function ({ value }, set = 'default') {
    const sets = {
        default: /^\p{Ll}+$/u,
        latin: /^[a-z]+$/,
    };
    const selectedSet = utils.has(sets, set) ? set : 'default';
    return sets[selectedSet].test(String(value));
};

/**
 * Determine if the given input's value matches one or more values or regular expressions.
 * @param context - The FormKitValidationContext
 * @public
 */
const matches = function matches({ value }, ...stack) {
    return stack.some((pattern) => {
        if (typeof pattern === 'string' &&
            pattern.substr(0, 1) === '/' &&
            pattern.substr(-1) === '/') {
            pattern = new RegExp(pattern.substr(1, pattern.length - 2));
        }
        if (pattern instanceof RegExp) {
            return pattern.test(String(value));
        }
        return pattern === value;
    });
};

/**
 * Determine if the given input's value is less than or equal to the maximum.
 * @param context - The FormKitValidationContext
 * @public
 */
const max = function max({ value }, maximum = 10) {
    if (Array.isArray(value)) {
        return value.length <= maximum;
    }
    return Number(value) <= Number(maximum);
};

/**
 * Determine if the given input's value is greater than or equal to the minimum.
 * @param context - The FormKitValidationContext
 * @public
 */
const min = function min({ value }, minimum = 1) {
    if (Array.isArray(value)) {
        return value.length >= minimum;
    }
    return Number(value) >= Number(minimum);
};

/**
 * Determine if the given input's value is not in a given stack.
 * @param context - The FormKitValidationContext
 * @public
 */
const not = function not({ value }, ...stack) {
    return !stack.some((item) => {
        if (typeof item === 'object') {
            return utils.eq(item, value);
        }
        return item === value;
    });
};

/**
 * Determine if the given input's value is numeric.
 * @param context - The FormKitValidationContext
 * @public
 */
const number = function number({ value }) {
    return !isNaN(value);
};

/**
 * Determine if any of the given inputs have a value.
 * @param context - The FormKitValidationContext
 * @public
 */
const require_one = function (node, ...inputNames) {
    if (!utils.empty(node.value))
        return true;
    const values = inputNames.map(name => { var _a; return (_a = node.at(name)) === null || _a === void 0 ? void 0 : _a.value; });
    return values.some(value => !utils.empty(value));
};
require_one.skipEmpty = false;

/**
 * Determine if the given input's value is required.
 * @param context - The FormKitValidationContext
 * @public
 */
const required = function required({ value }, action = 'default') {
    return action === 'trim' && typeof value === 'string'
        ? !utils.empty(value.trim())
        : !utils.empty(value);
};
/**
 * This rules should run even if the inputs is empty (obviously)
 */
required.skipEmpty = false;

/**
 * Determine if the given input's value starts with a substring.
 * @param context - The FormKitValidationContext
 * @public
 */
const starts_with = function starts_with({ value }, ...stack) {
    if (typeof value === 'string' && stack.length) {
        return stack.some((item) => {
            return value.startsWith(item);
        });
    }
    else if (typeof value === 'string' && stack.length === 0) {
        return true;
    }
    return false;
};

/**
 * Determine if the given input's value contains only symbol characters.
 * @param context - The FormKitValidationContext
 * @public
 */
const symbol = function ({ value }) {
    return /^[!-/:-@[-`{-~]+$/.test(String(value));
};

/**
 * Determine if the given input's value contains only uppercase characters.
 * @param context - The FormKitValidationContext
 * @public
 */
const uppercase = function ({ value }, set = 'default') {
    const sets = {
        default: /^\p{Lu}+$/u,
        latin: /^[A-Z]+$/,
    };
    const selectedSet = utils.has(sets, set) ? set : 'default';
    return sets[selectedSet].test(String(value));
};

/**
 * Determine if the given input's value is a URL.
 * @param context - The FormKitValidationContext
 * @public
 */
const url = function url({ value }, ...stack) {
    try {
        const protocols = stack.length ? stack : ['http:', 'https:'];
        const url = new URL(String(value));
        return protocols.includes(url.protocol);
    }
    catch {
        return false;
    }
};

exports.accepted = accepted;
exports.alpha = alpha;
exports.alpha_spaces = alpha_spaces;
exports.alphanumeric = alphanumeric;
exports.between = between;
exports.confirm = confirm;
exports.contains_alpha = contains_alpha;
exports.contains_alpha_spaces = contains_alpha_spaces;
exports.contains_alphanumeric = contains_alphanumeric;
exports.contains_lowercase = contains_lowercase;
exports.contains_numeric = contains_numeric;
exports.contains_symbol = contains_symbol;
exports.contains_uppercase = contains_uppercase;
exports.date_after = date_after;
exports.date_before = date_before;
exports.date_between = date_between;
exports.date_format = date_format;
exports.email = email;
exports.ends_with = ends_with;
exports.is = is;
exports.length = length;
exports.lowercase = lowercase;
exports.matches = matches;
exports.max = max;
exports.min = min;
exports.not = not;
exports.number = number;
exports.require_one = require_one;
exports.required = required;
exports.starts_with = starts_with;
exports.symbol = symbol;
exports.uppercase = uppercase;
exports.url = url;
