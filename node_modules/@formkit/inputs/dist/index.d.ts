/**
 * The official FormKit Inputs plugin. This package contains the source code for
 * all native HTML input types. Read the
 * {@link https://formkit.com/essentials/inputs | inputs documentation} for
 * usage instructions.
 *
 * @packageDocumentation
 */

import { FormKitClasses } from '@formkit/core';
import { FormKitExtendableSchemaRoot } from '@formkit/core';
import { FormKitFrameworkContext } from '@formkit/core';
import { FormKitGroupValue } from '@formkit/core';
import { FormKitLibrary } from '@formkit/core';
import { FormKitMessage } from '@formkit/core';
import { FormKitMiddleware } from '@formkit/core';
import { FormKitNode } from '@formkit/core';
import { FormKitPlugin } from '@formkit/core';
import { FormKitSchemaAttributes as FormKitSchemaAttributes_2 } from '@formkit/core';
import { FormKitSchemaComponent as FormKitSchemaComponent_2 } from '@formkit/core';
import { FormKitSchemaCondition as FormKitSchemaCondition_2 } from '@formkit/core';
import { FormKitSchemaDefinition } from '@formkit/core';
import { FormKitSchemaDOMNode as FormKitSchemaDOMNode_2 } from '@formkit/core';
import { FormKitSchemaFormKit as FormKitSchemaFormKit_2 } from '@formkit/core';
import { FormKitSchemaNode } from '@formkit/core';
import { FormKitTypeDefinition } from '@formkit/core';

/**
 * Applies attributes to a given schema section by applying a higher order
 * function that merges a given set of attributes into the node.
 *
 * @param attrs - Attributes to apply to a {@link FormKitSchemaExtendableSection
 * | FormKitSchemaExtendableSection}.
 * @param section - A section to apply attributes to.
 *
 * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}
     *
     * @public
     */
 export declare function $attrs(attrs: FormKitSchemaAttributes_2 | (() => FormKitSchemaAttributes_2), section: FormKitSchemaExtendableSection): FormKitSchemaExtendableSection;

 /**
  * Extends a schema node with a given set of extensions.
  *
  * @param section - A section to apply an extension to.
  * @param extendWith - A partial schema snippet to apply to the section.
  *
  * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}
      *
      * @public
      */
  export declare function $extend(section: FormKitSchemaExtendableSection, extendWith: Partial<FormKitSchemaNode>): FormKitSchemaExtendableSection;

  /**
   * Applies a condition to a given schema section.
   *
   * @param varName - The name of the variable that holds the current instance.
   * @param inName - The variable we are iterating over.
   * @param section - A section to repeat.
   *
   * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}
       *
       * @public
       */
   export declare function $for(varName: string, inName: string, section: FormKitSchemaExtendableSection): (extensions: Record<string, Partial<FormKitSchemaNode>>) => FormKitSchemaNode;

   /**
    * Applies a condition to a given schema section.
    *
    * @param condition - A schema condition to apply to a section.
    * @param then - The section that applies if the condition is true.
    * @param otherwise - (else) The section that applies if the condition is false.
    *
    * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}
        *
        * @public
        */
    export declare function $if(condition: string, then: FormKitSchemaExtendableSection, otherwise?: FormKitSchemaExtendableSection): FormKitSchemaExtendableSection;

    /**
     * Creates a root schema section.
     *
     * @param section - A section to make a root from.
     *
     * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}
         *
         * @public
         */
     export declare function $root(section: FormKitSchemaExtendableSection): FormKitExtendableSchemaRoot;

     /**
      * Actions section that shows the action buttons
      *
      * @public
      * @__NO_SIDE_EFFECTS__
      */
     export declare const actions: FormKitSection<FormKitSchemaExtendableSection>;

     /**
      * An attempt to capture all non-undefined values. This is used to define
      * various conditionals where undefined is not a concrete type, but all other
      * values need to take one logical branch.
      *
      * @public
      */
     export declare type AllReals = number | string | boolean | CallableFunction | Array<any> | null | Record<any, any>;

     /**
      * Box section used for grouping options
      *
      * @public
      * @__NO_SIDE_EFFECTS__
      */
     export declare const box: FormKitSection<FormKitSchemaExtendableSection>;

     /**
      * Option help section
      *
      * @public
      * @__NO_SIDE_EFFECTS__
      */
     export declare const boxHelp: FormKitSection<FormKitSchemaExtendableSection>;

     /**
      * Box Inner section
      *
      * @public
      * @__NO_SIDE_EFFECTS__
      */
     export declare const boxInner: FormKitSection<FormKitSchemaExtendableSection>;

     /**
      * Label section for options
      *
      * @public
      * @__NO_SIDE_EFFECTS__
      */
     export declare const boxLabel: FormKitSection<FormKitSchemaExtendableSection>;

     /**
      * Option section used to show an option
      *
      * @public
      * @__NO_SIDE_EFFECTS__
      */
     export declare const boxOption: FormKitSection<FormKitSchemaExtendableSection>;

     /**
      * Options section used to wrap all option sections in a list
      *
      * @public
      * @__NO_SIDE_EFFECTS__
      */
     export declare const boxOptions: FormKitSection<FormKitSchemaExtendableSection>;

     /**
      * Wrapper section for options
      *
      * @public
      * @__NO_SIDE_EFFECTS__
      */
     export declare const boxWrapper: FormKitSection<FormKitSchemaExtendableSection>;

     /**
      * Input definition for a button.
      * @public
      */
     declare const button: FormKitTypeDefinition;
     export { button }
     export { button as submit }

     /**
      * Input section for a button
      *
      * @public
      * @__NO_SIDE_EFFECTS__
      */
     export declare const buttonInput: FormKitSection<FormKitSchemaExtendableSection>;

     /**
      * Default section for a button
      *
      * @public
      * @__NO_SIDE_EFFECTS__
      */
     export declare const buttonLabel: FormKitSection<FormKitSchemaExtendableSection>;

     /**
      * A feature that allows casting to numbers.
      *
      * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
      *
      * @public
      */
     export declare function casts(node: FormKitNode): void;

     /**
      * Input definition for a checkbox(ess).
      * @public
      */
     export declare const checkbox: FormKitTypeDefinition;

     /**
      * A feature that adds checkbox selection support.
      *
      * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
      *
      * @public
      */
     export declare function checkboxes(node: FormKitNode): void;

     /**
      * Creates a plugin based on a list of {@link @formkit/core#FormKitLibrary | FormKitLibrary}.
      *
      * @param libraries - One or many {@link @formkit/core#FormKitLibrary | FormKitLibrary}.
      *
      * @returns {@link @formkit/core#FormKitPlugin | FormKitPlugin}
          *
          * @public
          */
      export declare function createLibraryPlugin(...libraries: FormKitLibrary[]): FormKitPlugin;

      /**
       * Creates a new reusable section.
       *
       * @param section - A single section of schema
       * @param el - The element or a function that returns a schema node.
       * @param root - When true, returns a FormKitExtendableSchemaRoot. When false,
       * returns a FormKitSchemaExtendableSection.
       *
       * @returns Returns a {@link @formkit/core#FormKitExtendableSchemaRoot
       * | FormKitExtendableSchemaRoot} or a {@link
       * @formkit/core#FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}.
       *
       * @public
       */
      export declare function createSection(section: string, el: string | null | (() => FormKitSchemaNode), fragment: true): FormKitSection<FormKitExtendableSchemaRoot>;

      /**
       * @param section - A single section of schema
       * @param el - The element or a function that returns a schema node.
       *
       * @public
       */
      export declare function createSection(section: string, el: string | null | (() => FormKitSchemaNode)): FormKitSection<FormKitSchemaExtendableSection>;

      /**
       * @param section - A single section of schema
       * @param el - The element or a function that returns a schema node.
       * @param root - When false, returns a FormKitSchemaExtendableSection.
       *
       * @public
       */
      export declare function createSection(section: string, el: string | (() => FormKitSchemaNode), fragment: false): FormKitSection<FormKitSchemaExtendableSection>;

      /**
       * Decorator section
       *
       * @public
       * @__NO_SIDE_EFFECTS__
       */
      export declare const decorator: FormKitSection<FormKitSchemaExtendableSection>;

      /**
       * Adds icon props definition.
       *
       * @param sectionKey - the location the icon should be loaded.
       * @param defaultIcon - the icon that should be loaded if a match is found in the user's CSS.
       *
       * @returns A {@link @formkit/core#FormKitPlugin | FormKitPlugin}.
       *
       * @public
       */
      export declare function defaultIcon(sectionKey: string, defaultIcon: string): (node: FormKitNode) => void;

      /**
       * A feature that allows disabling children of this node.
       *
       * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
       *
       * @public
       */
      export declare function disablesChildren(node: FormKitNode): void;

      /**
       * Runs a callback over every section in a schema. if stopOnCallbackReturn is true
       * and the callback returns a value, the loop will stop and return that value.
       *
       * @param schema - A {@link @formkit/core#FormKitSchemaNode | FormKitSchemaNode} array.
       * @param callback - A callback to run on every section.
       * @param stopOnCallbackReturn - If true, the loop will stop if the callback returns a value.
       * @param schemaParent - The parent of the current schema node.
       *
       * @returns
       *
       * @public
       */
      export declare function eachSection<T>(schema: FormKitSchemaDefinition, callback: (section: FormKitSchemaComponent_2 | FormKitSchemaDOMNode_2, schemaParent: FormKitSchemaNode[], schema: FormKitSchemaCondition_2) => T, stopOnCallbackReturn?: boolean, schemaParent?: FormKitSchemaNode[]): T | void;

      /**
       * Extends a single schema node with an extension. The extension can be any
       * partial node including strings.
       *
       * @param schema - The base schema node.
       * @param extension - The values to extend on the base schema node.
       *
       * @returns {@link @formkit/core#FormKitSchemaNode | FormKitSchemaNode}
           *
           * @public
           */
       export declare function extendSchema(schema: FormKitSchemaNode, extension?: Partial<FormKitSchemaNode>): FormKitSchemaNode;

       /**
        * Fieldset section, used to describe help
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const fieldset: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * Input definition for a file input.
        * @public
        */
       export declare const file: FormKitTypeDefinition;

       /**
        * Input section for a file input
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const fileInput: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * File item section for showing a file name
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const fileItem: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * File list section to show all file names
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const fileList: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * File name section to show the file name
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const fileName: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * File remove section to show a remove button for files
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const fileRemove: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * A feature to add file handling support to an input.
        *
        * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
        *
        * @public
        */
       export declare function files(node: FormKitNode): void;

       /**
        * Finds a seciton by name in a schema.
        *
        * @param schema - A {@link @formkit/core#FormKitSchemaDefinition | FormKitSchemaDefinition} array.
        * @param target - The name of the section to find.
        *
        * @returns a tuple of the schema and the section or a tuple of `false` and `false` if not found.
        *
        * @public
        */
       export declare function findSection(schema: FormKitSchemaDefinition, target: string): [false, false] | [FormKitSchemaNode[] | false, FormKitSchemaCondition_2];

       /**
        * Input definition for a form.
        * @public
        */
       export declare const form: FormKitTypeDefinition;

       /**
        * Form section
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const formInput: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * The possible value types of attributes (in the schema).
        *
        * @public
        */
       declare type FormKitAttributeValue =
       | string
       | number
       | boolean
       | undefined
       | FormKitSchemaAttributes
       | FormKitSchemaAttributesCondition

       /**
        * General input events available to all FormKit inputs.
        * @public
        */
       export declare interface FormKitBaseEvents<Props extends FormKitInputs<Props>> {
           (event: 'input', value: PropType<Props, 'value'>, node: FormKitNode): any;
           (event: 'inputRaw', value: PropType<Props, 'value'>, node: FormKitNode): any;
           (event: 'input-raw', value: PropType<Props, 'value'>, node: FormKitNode): any;
           (event: 'update:modelValue', value: PropType<Props, 'value'>): any;
           (event: 'update:model-value', value: PropType<Props, 'value'>): any;
           (event: 'node', node: FormKitNode): any;
       }

       /**
        * Base props that should be applied to all FormKit inputs. These are not actual
        * runtime props and are pulled from the context.attrs object. Many of these are
        * just html attributes that are passed through to the input element.
        *
        * @public
        */
       export declare interface FormKitBaseProps {
           /**
            * HTML Attribute, read more here: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#accept
            */
           accept: string;
           action: string;
           actions: 'true' | 'false' | boolean;
           dirtyBehavior: 'touched' | 'compare';
           disabled: 'true' | 'false' | boolean;
           enctype: string;
           help: string;
           ignore: 'true' | 'false' | boolean;
           label: string;
           max: string | number;
           method: string;
           min: string | number;
           multiple: 'true' | 'false' | boolean;
           preserve: 'true' | 'false' | boolean;
           preserveErrors: 'true' | 'false' | boolean;
           placeholder: string;
           step: string | number;
       }

       /**
        * Nearly all inputs in FormKit have a "base" set of slots. This is the
        * "sandwich" around the input itself, like the wrappers, help text, error
        * messages etc. Several other input’s slots extend this base interface.
        * @public
        */
       export declare interface FormKitBaseSlots<Props extends FormKitInputs<Props>> {
           help: FormKitSlotData<Props>;
           inner: FormKitSlotData<Props>;
           input: FormKitSlotData<Props>;
           label: FormKitSlotData<Props>;
           message: FormKitSlotData<Props, {
               message: FormKitMessage;
           }>;
           messages: FormKitSlotData<Props>;
           outer: FormKitSlotData<Props>;
           prefix: FormKitSlotData<Props>;
           prefixIcon: FormKitSlotData<Props>;
           suffix: FormKitSlotData<Props>;
           suffixIcon: FormKitSlotData<Props>;
           wrapper: FormKitSlotData<Props>;
       }

       /**
        * The slots available to the radio and checkbox inputs when options are
        * provided.
        * @public
        */
       export declare interface FormKitBoxSlots<Props extends FormKitInputs<Props>> {
           fieldset: FormKitSlotData<Props>;
           legend: FormKitSlotData<Props>;
           help: FormKitSlotData<Props>;
           options: FormKitSlotData<Props>;
           option: FormKitSlotData<Props, OptionSlotData<Props>>;
           wrapper: FormKitSlotData<Props, OptionSlotData<Props>>;
           inner: FormKitSlotData<Props, OptionSlotData<Props>>;
           input: FormKitSlotData<Props, OptionSlotData<Props>>;
           label: FormKitSlotData<Props, OptionSlotData<Props>>;
           prefix: FormKitSlotData<Props, OptionSlotData<Props>>;
           suffix: FormKitSlotData<Props, OptionSlotData<Props>>;
           decorator: FormKitSlotData<Props, OptionSlotData<Props>>;
           decoratorIcon: FormKitSlotData<Props, OptionSlotData<Props>>;
           optionHelp: FormKitSlotData<Props, OptionSlotData<Props>>;
           box: FormKitSlotData<Props, OptionSlotData<Props>>;
           icon: FormKitSlotData<Props, OptionSlotData<Props>>;
           message: FormKitSlotData<Props, {
               message: FormKitMessage;
           }>;
           messages: FormKitSlotData<Props>;
       }

       /**
        * The slots available to the button input, these extend the base slots.
        *
        * @public
        */
       export declare type FormKitButtonSlots<Props extends FormKitInputs<Props>> = Omit<FormKitBaseSlots<Props>, 'inner'> & {
           default: FormKitSlotData<Props>;
       };

       /**
        * The slots available to the checkbox inputs even when options are not provided, these extend the base slots.
        * @public
        */
       export declare interface FormKitCheckboxSlots<Props extends FormKitInputs<Props>> extends FormKitBaseSlots<Props> {
           decorator: FormKitSlotData<Props, OptionSlotData<Props>>;
           decoratorIcon: FormKitSlotData<Props, OptionSlotData<Props>>;
       }

       /**
        * These are props that are used as conditionals in one or more inputs, and as
        * such they need to be defined on all input types. These should all be defined
        * explicitly as "undefined" here, and then defined as their specific type
        * in the FormKitInputProps interface only on the inputs that use them.
        * @public
        */
       export declare interface FormKitConditionalProps {
           onValue: undefined;
           offValue: undefined;
           options: undefined;
           number: undefined;
       }

       /**
        * All FormKit events should be included for a given set of props.
        *
        * @public
        */
       export declare type FormKitEvents<Props extends FormKitInputs<Props>> = MergedEvents<Props>;

       /**
        * In a perfect world this interface would not be required at all. However, Vue
        * expects the interfaces to be defined as method overloads. Unfortunately since
        * our events interface uses generics UnionToIntersection is not able to be used
        * meaning that we lose event data if we store the events as a standard
        * interface with property keys. The only way we have found to reliably get
        * Volar (as of June 2023) to properly recognize all defined events is to use
        * a the "standard" method overload approach (see FormKitBaseEvents).
        *
        * (Basically we cannot use the events in this interface to automatically
        * produce the FormKitBaseEvents without Volar loosing event data)
        *
        * This means we have no way to get the event names out of the interface so we
        * cannot properly use them in our props. This matters for things like TSX
        * support where the event names need to be available as `onEventName` props.
        *
        * This interface is used to manually patch that gap in the type system. These
        * types should match up 1-1 with the events defined in FormKitBaseEvents as
        * well as FormKitInputEvents.
        *
        * @public
        */
       export declare interface FormKitEventsAsProps {
           onInput: (value: unknown, node: FormKitNode) => any;
           onInputRaw: (value: unknown, node: FormKitNode) => any;
           'onUpdate:modelValue': (value: unknown, node: FormKitNode) => any;
           onNode: (node: FormKitNode) => any;
       }

       /**
        * A single file object in FormKit’s synthetic "FileList".
        *
        * @public
        */
       export declare interface FormKitFile {
           name: string;
           file?: File;
       }

       /**
        * The slots available to the file input, these extend the base slots.
        * @public
        */
       export declare interface FormKitFileSlots<Props extends FormKitInputs<Props>> extends FormKitBaseSlots<Props> {
           fileList: FormKitSlotData<Props>;
           fileItem: FormKitSlotData<Props>;
           fileItemIcon: FormKitSlotData<Props, {
               file: FormKitFile;
           }>;
           fileName: FormKitSlotData<Props, {
               file: FormKitFile;
           }>;
           fileRemove: FormKitSlotData<Props, {
               file: FormKitFile;
           }>;
           fileRemoveIcon: FormKitSlotData<Props, {
               file: FormKitFile;
           }>;
           noFiles: FormKitSlotData<Props>;
       }

       /**
        * A synthetic array-based "FileList".
        *
        * @public
        */
       export declare type FormKitFileValue = FormKitFile[];

       /**
        * Unique events emitted by each FormKit input. The shape of this interface is:
        *
        * ```ts
        * interface FormKitInputEvents<Props extends Inputs> {
        *   typeString: { customEvent: (value: PropType<Props, 'value'>) => any } // <-- All unique events
        * }
        * ```
        *
        * All inputs will also inherit all events from FormKitBaseInputEvents.
        * @public
        */
       export declare interface FormKitInputEvents<Props extends FormKitInputs<Props>> {
           form: {
               (event: 'submit-raw', e: Event, node: FormKitNode): any;
               (event: 'submit-invalid', node: FormKitNode): any;
               (event: 'submit', data: any, node: FormKitNode): any;
           };
       }

       /**
        * See the comment tome on {@link FormKitEventsAsProps} for why this type is
        * necessary.
        *
        * @public
        */
       export declare interface FormKitInputEventsAsProps<Props extends FormKitInputs<Props>> {
           form: {
               onSubmitRaw: (e: Event, node: FormKitNode) => any;
               onSubmitInvalid: (node: FormKitNode) => any;
               onSubmit: (data: any, node: FormKitNode) => any;
           };
       }

       /**
        * This is the base interface for providing prop definitions to the FormKit
        * component. It is used to define the props that are available to the each
        * component in the FormKit library by using a discriminated union type. The
        * structure of this interface is:
        *
        * ```ts
        * interface FormKitInputProps {
        *  typeString: { type: 'string'; value?: string } // <-- All unique props
        * }
        * ```
        *
        * All inputs will also inherit all props from FormKitBaseInputProps.
        *
        * Note: It is important that all inputs provide a type and a value prop.
        * @public
        */
       export declare interface FormKitInputProps<Props extends FormKitInputs<Props>> {
           button: {
               type: 'button';
               value?: undefined;
           };
           checkbox: {
               type: 'checkbox';
               options?: FormKitOptionsProp;
               onValue?: any;
               offValue?: any;
               value?: Props['options'] extends Record<infer T, string> ? T[] : Props['options'] extends FormKitOptionsItem[] ? Array<Props['options'][number]['value']> : Props['options'] extends Array<infer T> ? T[] : (Props['onValue'] extends AllReals ? Props['onValue'] : true) | (Props['offValue'] extends AllReals ? Props['offValue'] : false);
           };
           color: {
               type: 'color';
               value?: string;
           };
           date: {
               type: 'date';
               value?: string;
           };
           datetimeLocal: {
               type: 'datetimeLocal';
               value?: string;
           };
           email: {
               type: 'email';
               value?: string;
           };
           file: {
               type: 'file';
               value?: FormKitFile[];
           };
           form: {
               type: 'form';
               value?: FormKitGroupValue;
               actions?: boolean | string;
               submitAttrs?: Record<string, any>;
               submitBehavior?: 'disabled' | 'live';
               incompleteMessage?: false | string;
           };
           group: {
               type: 'group';
               value?: FormKitGroupValue;
           };
           hidden: {
               type: 'hidden';
               value?: Props['number'] extends AllReals ? number : string;
               number?: 'integer' | 'float' | 'true' | true;
           };
           list: {
               type: 'list';
               value?: unknown[];
               dynamic?: boolean | 'true' | 'false';
               sync?: boolean | 'true' | 'false';
           };
           meta: {
               type: 'meta';
               value?: any;
           };
           month: {
               type: 'month';
               value?: string;
           };
           number: {
               type: 'number';
               value?: Props['number'] extends AllReals ? number : string;
               number?: 'integer' | 'float' | 'true' | true;
           };
           password: {
               type: 'password';
               value?: string;
           };
           radio: {
               type: 'radio';
               options: FormKitOptionsProp;
               value?: FormKitOptionsValue<Props['options']>;
           };
           range: {
               type: 'range';
               value?: Props['number'] extends AllReals ? number : string;
               number?: 'integer' | 'float' | 'true' | true;
           };
           search: {
               type: 'search';
               value?: Props['number'] extends AllReals ? number | string : string;
               number?: 'integer' | 'float' | 'true' | true;
           };
           select: {
               type: 'select';
               options?: FormKitOptionsPropWithGroups;
               value?: FormKitOptionsValue<Props['options']>;
           };
           submit: {
               type: 'submit';
               value?: string;
           };
           tel: {
               type: 'tel';
               value?: Props['number'] extends AllReals ? number | string : string;
               number?: 'integer' | 'float' | 'true' | true;
           };
           text: {
               type: 'text';
               value?: Props['number'] extends AllReals ? number | string : string;
               number?: 'integer' | 'float' | 'true' | true;
           };
           textarea: {
               type: 'textarea';
               value?: string;
           };
           time: {
               type: 'time';
               value?: string;
           };
           url: {
               type: 'url';
               value?: string;
           };
           week: {
               type: 'week';
               value?: string;
           };
           _: {
               type?: Props['type'] extends keyof FormKitInputProps<Props> ? never : Props['type'];
               value?: string;
           };
       }

       /**
        * All FormKit inputs should be included for this type.
        * @public
        */
       export declare type FormKitInputs<Props extends FormKitInputs<Props>> = MergedProps<Props>[keyof MergedProps<Props>];

       /**
        * Either a schema node, or a function that returns a schema node.
        *
        * @public
        */
       export declare type FormKitInputSchema = ((children?: FormKitSchemaDefinition) => FormKitSchemaNode) | FormKitSchemaNode;

       /**
        * Slots provided by each FormKit input. The shape of this interface is:
        *
        * ```ts
        * interface FormKitInputSlots<Props extends Inputs> {
        *   typeString: { default: (value: PropType<Props, 'value'>) => any } // <-- All unique slots
        * }
        * ```
        *
        * There is no automatic inheritance of slots — each slot must be explicitly
        * defined for each input.
        * @public
        */
       export declare interface FormKitInputSlots<Props extends FormKitInputs<Props>> {
           text: FormKitTextSlots<Props>;
           color: FormKitTextSlots<Props>;
           date: FormKitTextSlots<Props>;
           'datetime-local': FormKitTextSlots<Props>;
           email: FormKitTextSlots<Props>;
           month: FormKitTextSlots<Props>;
           number: FormKitTextSlots<Props>;
           password: FormKitTextSlots<Props>;
           search: FormKitTextSlots<Props>;
           tel: FormKitTextSlots<Props>;
           time: FormKitTextSlots<Props>;
           url: FormKitTextSlots<Props>;
           week: FormKitTextSlots<Props>;
           range: FormKitTextSlots<Props>;
           textarea: FormKitTextSlots<Props>;
           select: FormKitSelectSlots<Props>;
           radio: Props['options'] extends AllReals ? FormKitBoxSlots<Props> : FormKitBaseSlots<Props>;
           list: {
               default: FormKitSlotData<Props>;
           };
           hidden: {
               input: FormKitSlotData<Props>;
           };
           meta: {
               wrapper: FormKitSlotData<Props>;
           };
           group: {
               default: FormKitSlotData<Props>;
           };
           form: {
               form: FormKitSlotData<Props>;
               default: FormKitSlotData<Props>;
               message: FormKitSlotData<Props, {
                   message: FormKitMessage;
               }>;
               messages: FormKitSlotData<Props>;
               actions: FormKitSlotData<Props>;
               submit: FormKitSlotData<Props>;
           };
           file: FormKitFileSlots<Props>;
           checkbox: Props['options'] extends AllReals ? FormKitBoxSlots<Props> : FormKitCheckboxSlots<Props>;
           submit: FormKitButtonSlots<Props>;
           button: FormKitButtonSlots<Props>;
       }

       /**
        * A full loop statement in tuple syntax. Can be read like "foreach value, key? in list".
        *
        * @public
        */
       declare type FormKitListStatement =
       | [value: any, key: number | string, list: FormKitListValue]
       | [value: any, list: FormKitListValue]

       /**
        * The value being listed out. Can be an array, an object, or a number.
        *
        * @public
        */
       declare type FormKitListValue =
       | string
       | Record<string, any>
       | Array<string | number | Record<string, any>>
       | number

       /**
        * Option groups should always be formatted as an array of objects with group and nested options
        */
       export declare interface FormKitOptionsGroupItem {
           group: string;
           options: FormKitOptionsList;
           attrs?: Record<string, any>;
       }

       /**
        * Option groups should always be formatted as an array of objects with group and nested options
        */
       export declare interface FormKitOptionsGroupItemProp {
           group: string;
           options: FormKitOptionsProp;
           attrs?: Record<string, any>;
       }

       /**
        * Options should always be formatted as an array of objects with label and value
        * properties.
        *
        * @public
        */
       export declare interface FormKitOptionsItem<V = unknown> {
           label: string;
           value: V;
           attrs?: {
               disabled?: boolean;
           } & Record<string, any>;
           __original?: any;
           [index: string]: any;
       }

       /**
        * An array of option items.
        *
        * @public
        */
       export declare type FormKitOptionsList = FormKitOptionsItem[];

       /**
        * An array of option items with a group.
        *
        * @public
        */
       export declare type FormKitOptionsListWithGroups = Array<FormKitOptionsItem | FormKitOptionsGroupItem>;

       /**
        * An array of option items with a group support — where the `option` of the
        * groups can be any valid FormKitOptionsProp type.
        */
       export declare type FormKitOptionsListWithGroupsProp = Array<FormKitOptionsItem | FormKitOptionsGroupItemProp>;

       /**
        * The types of options that can be passed to the options prop.
        *
        * @public
        */
       export declare type FormKitOptionsProp = FormKitOptionsPropExtensions[keyof FormKitOptionsPropExtensions];

       /**
        * Allows for prop extensions to be defined by using an interface whose keys
        * are ignored, but values are applied to a union type. This allows for any
        * third party code to extend the options prop by using module augmentation
        * to add new values to the union type.
        *
        * @public
        */
       export declare interface FormKitOptionsPropExtensions {
           arrayOfStrings: string[];
           arrayOfNumbers: number[];
           optionsList: FormKitOptionsList;
           valueLabelPojo: Record<string | number, string>;
       }

       /**
        * The types of options that can be passed to the options prop.
        *
        * @public
        */
       export declare type FormKitOptionsPropWithGroups = FormKitOptionsProp | FormKitOptionsListWithGroupsProp;

       /**
        * The proper shape of data to be passed to options prop.
        * @public
        */
       export declare type FormKitOptionsValue<Options> = Options extends FormKitOptionsProp ? Options extends Record<infer T, string> ? T : Options extends FormKitOptionsItem[] ? Options[number]['value'] : Options extends Array<infer T> ? T : unknown : unknown;

       /**
        * Typings for all the built in runtime props.
        *
        * Warning: As of writing these are only specific to Vue’s runtime prop
        * requirements and should not be used as any kind of external API as they are
        * subject to change.
        *
        * @public
        */
       export declare interface FormKitRuntimeProps<Props extends FormKitInputs<Props>> {
           /**
            * An object of configuration data for the input and its children.
            */
           config: Record<string, any>;
           /**
            * An object of classes to be applied to the input.
            */
           classes: Record<string, string | Record<string, boolean> | FormKitClasses>;
           /**
            * Amount of time to debounce input before committing.
            */
           delay: number;
           /**
            * An array of errors for the input.
            */
           errors: string[];
           /**
            * A object of values
            */
           inputErrors: Record<string, string[]>;
           /**
            * An explicit index to mount a child of a list at.
            */
           index: number;
           /**
            * A globally unique identifier for the input — this passes through to the
            * id attribute.
            */
           id: string;
           /**
            * The dynamic value of the input.
            */
           modelValue: PropType<Props, 'value'>;
           /**
            * The name of the input.
            */
           name: string;
           /**
            * An explicit parent node for the input.
            */
           parent: FormKitNode;
           /**
            * An array of plugins to apply to the input.
            */
           plugins: FormKitPlugin[];
           /**
            * An object of sections to merge with the input’s internal schema.
            */
           sectionsSchema: Record<string, Partial<FormKitSchemaNode> | FormKitSchemaCondition_2>;
           /**
            * A boolean indicating whether the input should be synced with the model.
            */
           sync: boolean | undefined;
           /**
            * The type of the input.
            */
           type: string | FormKitTypeDefinition;
           /**
            * A validation string or array of validation rules.
            */
           validation: string | Array<[rule: string, ...args: any]>;
           /**
            * An object of validation messages to use for the input.
            */
           validationMessages: Record<string, string | ((ctx: {
               node: FormKitNode;
               name: string;
               args: any[];
           }) => string)>;
           /**
            * An object of additional validation rules to use for the input.
            */
           validationRules: Record<string, (node: FormKitNode) => boolean | Promise<boolean>>;
           /**
            * Use this to override the default validation label in validation messages.
            */
           validationLabel: string | ((node: FormKitNode) => string);
       }

       /**
        * DOM attributes are simple string dictionaries.
        *
        * @public
        */
       declare type FormKitSchemaAttributes =
       | {
           [index: string]: FormKitAttributeValue
       }
       | null
       | FormKitSchemaAttributesCondition

       /**
        * Conditions nested inside attribute declarations.
        *
        * @public
        */
       declare interface FormKitSchemaAttributesCondition {
           if: string
           then: FormKitAttributeValue
           else?: FormKitAttributeValue
       }

       /**
        * Properties available when defining a generic non-FormKit component.
        *
        * @public
        */
       declare type FormKitSchemaComponent = {
           $cmp: string
           props?: Record<string, any>
       } & FormKitSchemaProps

       /**
        * A schema node that determines _which_ content to render.
        *
        * @public
        */
       declare type FormKitSchemaCondition = {
           if: string
           then: FormKitSchemaNode_2 | FormKitSchemaNode_2[]
           else?: FormKitSchemaNode_2 | FormKitSchemaNode_2[]
       }

       /**
        * Properties available when using a DOM node.
        *
        * @public
        */
       declare type FormKitSchemaDOMNode = {
           $el: string | null
           attrs?: FormKitSchemaAttributes
       } & FormKitSchemaProps

       /**
        * A function that is called with an extensions argument and returns a valid
        * schema node.
        *
        * @public
        */
       export declare interface FormKitSchemaExtendableSection {
           (extensions: Record<string, Partial<FormKitSchemaNode>>): FormKitSchemaNode;
           _s?: string;
       }

       /**
        * Syntactic sugar for a FormKitSchemaComponent node that uses FormKit.
        *
        * @public
        */
       declare type FormKitSchemaFormKit = {
           $formkit: string
       } & Record<string, any> &
       FormKitSchemaProps

       /**
        * Meta attributes are not used when parsing the schema, but can be used to
        * create tooling.
        *
        * @public
        */
       declare type FormKitSchemaMeta = {
           [key: string]:
           | string
           | number
           | boolean
           | undefined
           | null
           | CallableFunction
           | FormKitSchemaMeta
       }

       /**
        * Properties available then defining a schema node.
        *
        * @public
        */
       declare type FormKitSchemaNode_2 =
       | FormKitSchemaDOMNode
       | FormKitSchemaComponent
       | FormKitSchemaTextNode
       | FormKitSchemaCondition
       | FormKitSchemaFormKit

       /**
        * Properties available in all schema nodes.
        *
        * @public
        */
       declare interface FormKitSchemaProps {
           children?: string | FormKitSchemaNode_2[] | FormKitSchemaCondition
           key?: string
           if?: string
           for?: FormKitListStatement
           bind?: string
           meta?: FormKitSchemaMeta
       }

       /**
        * A simple text node.
        *
        * @public
        */
       declare type FormKitSchemaTextNode = string

       /**
        * A function that when called, returns a function that can in turn be called
        * with an extension parameter.
        *
        * @public
        */
       export declare interface FormKitSection<T = FormKitSchemaExtendableSection> {
           (...children: Array<FormKitSchemaExtendableSection | string | FormKitSchemaCondition>): T;
       }

       /**
        * The slots available to the select input, these extend the base slots.
        * @public
        */
       export declare interface FormKitSelectSlots<Props extends FormKitInputs<Props>> extends FormKitBaseSlots<Props> {
           default: FormKitSlotData<Props>;
           option: FormKitSlotData<Props, OptionSlotData<Props>>;
           selectIcon: FormKitSlotData<Props>;
       }

       /**
        * The shape of the context object that is passed to each slot.
        * @public
        */
       export declare interface FormKitSlotData<Props extends FormKitInputs<Props>, E extends Record<string, any> = {}> {
           (context: FormKitFrameworkContext<PropType<Props, 'value'>> & E): any;
       }

       /**
        * The slots available to the FormKitText input, these extend the base slots.
        * @public
        */
       export declare interface FormKitTextSlots<Props extends FormKitInputs<Props>> extends FormKitBaseSlots<Props> {
       }

       /**
        * A feature to add a submit handler and actions section.
        *
        * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
        *
        * @public
        */
       export declare function forms(node: FormKitNode): void;

       /**
        * A simple fragment section
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const fragment: FormKitSection<FormKitExtendableSchemaRoot>;

       /**
        * Input definition for a group.
        * @public
        */
       export declare const group: FormKitTypeDefinition;

       /**
        * Help section that shows help text
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const help: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * Input definition for a hidden input.
        * @public
        */
       export declare const hidden: FormKitTypeDefinition;

       /**
        * Icon section used by all icons
        *
        * @public
        */
       export declare const icon: (sectionKey: string, el?: string) => FormKitSchemaExtendableSection;

       /**
        * A feature that applies `ignore="true"` by default.
        *
        * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
        *
        * @public
        */
       export declare function ignores(node: FormKitNode): void;

       /**
        * A feature that ensures the input has an `initialValue` prop.
        *
        * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
        *
        * @public
        */
       export declare function initialValue(node: FormKitNode): void;

       /**
        * Inner section
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const inner: FormKitSection<FormKitSchemaExtendableSection>;

       declare namespace inputs {
           export {
               button,
               button as submit,
               checkbox,
               file,
               form,
               group,
               hidden,
               list,
               meta,
               radio,
               select,
               textarea,
               text,
               text as color,
               text as date,
               text as datetimeLocal,
               text as email,
               text as month,
               text as number,
               text as password,
               text as search,
               text as tel,
               text as time,
               text as url,
               text as week,
               text as range
           }
       }
       export { inputs }

       /**
        * Selects the "type" from the props if it exists, otherwise it defaults to
        * "text".
        *
        * @public
        */
       export declare type InputType<Props extends FormKitInputs<Props>> = Props['type'] extends string ? Props['type'] : 'text';

       /**
        * A helper to determine if an option is a group or an option.
        * @param option - An option
        */
       export declare function isGroupOption(option: FormKitOptionsItem | FormKitOptionsGroupItem | FormKitOptionsGroupItemProp): option is FormKitOptionsGroupItem;

       /**
        * Type guard for schema objects.
        *
        * @param schema - returns `true` if the node is a schema node but not a string
        * or conditional.
        *
        * @returns `boolean`
        *
        * @public
        */
       export declare function isSchemaObject(schema: Partial<FormKitSchemaNode>): schema is FormKitSchemaDOMNode_2 | FormKitSchemaComponent_2 | FormKitSchemaFormKit_2;

       /**
        * Checks if the current schema node is a slot condition.
        *
        * @example
        *
        * ```js
        * {
        *  if: '$slot.name',
        *  then: '$slot.name',
        *  else: []
        * } // this schema node would return true.
        * ```
        *
        * @param node - A {@link @formkit/core#FormKitSchemaNode | FormKitSchemaNode}.
        *
        * @returns `boolean`
        *
        * @public
        */
       export declare function isSlotCondition(node: FormKitSchemaNode): node is {
           if: string;
           then: string;
           else: FormKitSchemaNode | FormKitSchemaNode[];
       };

       /**
        * Label section with label element
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const label: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * Legend section, used instead of label when its grouping fields.
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const legend: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * Input definition for a list.
        * @public
        */
       export declare const list: FormKitTypeDefinition;

       /**
        * Creates a new feature that generates a localization message of type ui
        * for use on a given component.
        *
        * @param key - The key of the message.
        * @param value - The value of the message.
        *
        * @returns A {@link @formkit/core#FormKitPlugin | FormKitPlugin}.
        *
        * @public
        */
       export declare function localize(key: string, value?: string): (node: FormKitNode) => void;

       /**
        * Merge all events into a single type. This is then used as the structure for
        *
        * @public
        */
       export declare type MergedEvents<Props extends FormKitInputs<Props>> = InputType<Props> extends keyof FormKitInputEvents<Props> ? FormKitBaseEvents<Props> & FormKitInputEvents<Props>[InputType<Props>] : FormKitBaseEvents<Props>;

       /**
        * A merger of input props, base props, and conditional props. This is then
        * used as the structure for the FormKitInputs type.
        * @public
        */
       export declare type MergedProps<Props extends FormKitInputs<Props>> = {
           [K in keyof FormKitInputProps<Props>]: Omit<Partial<FormKitBaseProps>, keyof FormKitInputProps<Props>[K]> & Omit<Partial<FormKitRuntimeProps<Props>>, keyof FormKitInputProps<Props>[K]> & Omit<Partial<FormKitConditionalProps>, keyof FormKitInputProps<Props>[K]> & Partial<K extends keyof FormKitInputEventsAsProps<Props> ? Omit<FormKitEventsAsProps, keyof FormKitInputEventsAsProps<Props>[K]> & FormKitInputEventsAsProps<Props>[K] : FormKitEventsAsProps> & FormKitInputProps<Props>[K];
       };

       /**
        * Message section, shows a group of messages.
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const message: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * Messages section where all messages will be displayed.
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const messages: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * Input definition for a meta input.
        * @public
        */
       export declare const meta: FormKitTypeDefinition;

       /**
        * No file section that shows when there is no files
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const noFiles: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * A feature that normalizes box types (checkboxes, radios).
        *
        * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
        *
        * @returns A {@link @formkit/node#FormKitMiddleware | FormKitMiddleware}.
        *
        * @public
        */
       export declare function normalizeBoxes(node: FormKitNode): FormKitMiddleware<{
           prop: string | symbol;
           value: any;
       }>;

       /**
        * A function to normalize an array of objects, array of strings, or object of
        * key-values to use an array of objects with value and label properties.
        *
        * @param options - An un-normalized {@link FormKitOptionsProp | FormKitOptionsProp}.
        *
        * @returns A list of {@link FormKitOptionsList | FormKitOptionsList}.
        *
        * @public
        */
       export declare function normalizeOptions<T extends FormKitOptionsPropWithGroups>(options: T, i?: {
           count: number;
       }): T extends FormKitOptionsProp ? FormKitOptionsList : FormKitOptionsListWithGroups;

       /**
        * Option section used to show options
        *
        * @public
        */
       export declare const optGroup: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * Option section used to show options
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const option: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * A feature that converts the options prop to usable values, to be used by a
        * feature or a plugin.
        *
        * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
        *
        * @public
        */
       export declare function options(node: FormKitNode): void;

       /**
        * Options slot section that displays options when used with slots
        *
        * @public
        */
       export declare const optionSlot: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * The data available to slots that have an option in scope.
        * @public
        */
       export declare interface OptionSlotData<Props extends FormKitInputs<Props>> {
           option: FormKitOptionsItem<PropType<Props, 'value'>>;
       }

       /**
        * Outer section where most data attributes are assigned.
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const outer: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * Prefix section
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const prefix: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * Extracts the type from a given prop.
        * @public
        */
       export declare type PropType<Props extends FormKitInputs<Props>, T extends keyof FormKitInputs<Props>> = Extract<FormKitInputs<Props>, {
           type: Props['type'] extends string ? Props['type'] : 'text';
       }>[T];

       /**
        * Input definition for a radio.
        * @public
        */
       export declare const radio: FormKitTypeDefinition;

       /**
        * A feature to check if the value being checked is the current value.
        *
        * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
        *
        * @public
        */
       export declare function radios(node: FormKitNode): void;

       /**
        * Automatically rename any radio inputs.
        * @param node - A formkit node.
        * @returns
        */
       export declare function renamesRadios(node: FormKitNode): void;

       /**
        * All the explicit FormKit props that need to be passed to FormKit’s Vue
        * component instance.
        * @public
        */
       export declare const runtimeProps: string[];

       /**
        * Input definition for a select.
        * @public
        */
       export declare const select: FormKitTypeDefinition;

       /**
        * Input section used by selects
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const selectInput: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * Converts the options prop to usable values.
        * @param node - A formkit node.
        * @public
        */
       export declare function selects(node: FormKitNode): void;

       /**
        * Submit section that displays a submit button from a form
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const submitInput: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * Suffix section
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const suffix: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * Input definition for a text.
        * @public
        */
       declare const text: FormKitTypeDefinition;
       export { text as color }
       export { text as date }
       export { text as datetimeLocal }
       export { text as email }
       export { text as month }
       export { text as number }
       export { text as password }
       export { text as range }
       export { text as search }
       export { text as tel }
       export { text }
       export { text as time }
       export { text as url }
       export { text as week }

       /**
        * Input definition for a textarea.
        * @public
        */
       export declare const textarea: FormKitTypeDefinition;

       /**
        * Input section used by textarea inputs
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const textareaInput: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * Input section
        *
        * @public
        * @__NO_SIDE_EFFECTS__
        */
       export declare const textInput: FormKitSection<FormKitSchemaExtendableSection>;

       /**
        * Creates an input schema with all of the wrapping base schema.
        *
        * @param inputSection - Content to store in the input section key location.
        *
        * @returns {@link @formkit/core#FormKitExtendableSchemaRoot | FormKitExtendableSchemaRoot}
            *
            * @public
            */
        export declare function useSchema(inputSection: FormKitSection): FormKitSchemaExtendableSection;

        /**
         * Wrapper input section
         *
         * @public
         * @__NO_SIDE_EFFECTS__
         */
        export declare const wrapper: FormKitSection<FormKitSchemaExtendableSection>;

        export { }
