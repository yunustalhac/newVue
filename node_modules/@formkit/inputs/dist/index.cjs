'use strict';

var utils = require('@formkit/utils');
var core = require('@formkit/core');

/**
 * Creates a plugin based on a list of {@link @formkit/core#FormKitLibrary | FormKitLibrary}.
 *
 * @param libraries - One or many {@link @formkit/core#FormKitLibrary | FormKitLibrary}.
 *
 * @returns {@link @formkit/core#FormKitPlugin | FormKitPlugin}
 *
 * @public
 */
function createLibraryPlugin(...libraries) {
    /**
     * Merge all provided library items.
     */
    const library = libraries.reduce((merged, lib) => utils.extend(merged, lib), {});
    /* eslint-disable-next-line @typescript-eslint/no-empty-function */
    const plugin = () => { };
    /**
     * Enables the hook that exposes all library inputs.
     * @param node - The primary plugin
     */
    plugin.library = function (node) {
        const type = utils.camel(node.props.type);
        if (utils.has(library, type)) {
            node.define(library[type]);
        }
    };
    return plugin;
}

/**
 * All the explicit FormKit props that need to be passed to FormKit’s Vue
 * component instance.
 * @public
 */
const runtimeProps = [
    'classes',
    'config',
    'delay',
    'errors',
    'id',
    'index',
    'inputErrors',
    'modelValue',
    'onUpdate:modelValue',
    'name',
    'number',
    'parent',
    'plugins',
    'sectionsSchema',
    'type',
    'validation',
    'validationLabel',
    'validationMessages',
    'validationRules',
    // Runtime event props:
    'onInput',
    'onInputRaw',
    'onUpdate:modelValue',
    'onNode',
    'onSubmit',
    'onSubmitInvalid',
    'onSubmitRaw',
];
/**
 * A helper to determine if an option is a group or an option.
 * @param option - An option
 */
function isGroupOption(option) {
    return (option &&
        typeof option === 'object' &&
        'group' in option &&
        Array.isArray(option.options));
}

/**
 * A function to normalize an array of objects, array of strings, or object of
 * key-values to use an array of objects with value and label properties.
 *
 * @param options - An un-normalized {@link FormKitOptionsProp | FormKitOptionsProp}.
 *
 * @returns A list of {@link FormKitOptionsList | FormKitOptionsList}.
 *
 * @public
 */
function normalizeOptions(options, i = { count: 1 }) {
    if (Array.isArray(options)) {
        return options.map((option) => {
            if (typeof option === 'string' || typeof option === 'number') {
                return {
                    label: String(option),
                    value: String(option),
                };
            }
            if (typeof option == 'object') {
                if ('group' in option) {
                    option.options = normalizeOptions(option.options || [], i);
                    return option;
                }
                else if ('value' in option && typeof option.value !== 'string') {
                    Object.assign(option, {
                        value: `__mask_${i.count++}`,
                        __original: option.value,
                    });
                }
            }
            return option;
        });
    }
    return Object.keys(options).map((value) => {
        return {
            label: options[value],
            value,
        };
    });
}
/**
 * Given an {@link FormKitOptionsList | FormKitOptionsListWithGroups}, find the real value in the options.
 *
 * @param options - The {@link FormKitOptionsList | FormKitOptionsListWithGroups} to check for a given value
 * @param value - The value to return
 *
 * @returns `unknown`
 *
 * @public
 */
function optionValue(options, value, undefinedIfNotFound = false) {
    if (Array.isArray(options)) {
        for (const option of options) {
            if (typeof option !== 'object' && option)
                continue;
            if (isGroupOption(option)) {
                const found = optionValue(option.options, value, true);
                if (found !== undefined) {
                    return found;
                }
            }
            else if (value == option.value) {
                return '__original' in option ? option.__original : option.value;
            }
        }
    }
    return undefinedIfNotFound ? undefined : value;
}
/**
 * Determines if the value should be selected.
 *
 * @param valueA - Any type of value
 * @param valueB - Any type of value
 *
 * @returns `boolean`
 *
 * @public
 */
function shouldSelect(valueA, valueB) {
    if ((valueA === null && valueB === undefined) ||
        (valueA === undefined && valueB === null))
        return false;
    if (valueA == valueB)
        return true;
    if (utils.isPojo(valueA) && utils.isPojo(valueB))
        return utils.eq(valueA, valueB);
    return false;
}
/**
 * A feature that converts the options prop to usable values, to be used by a
 * feature or a plugin.
 *
 * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
 *
 * @public
 */
function options(node) {
    node.hook.prop((prop, next) => {
        if (prop.prop === 'options') {
            if (typeof prop.value === 'function') {
                node.props.optionsLoader = prop.value;
                prop.value = [];
            }
            else {
                prop.value = normalizeOptions(prop.value);
            }
        }
        return next(prop);
    });
}

/*@__NO_SIDE_EFFECTS__*/
function createSection(section, el, fragment = false) {
    return (...children) => {
        const extendable = (extensions) => {
            const node = !el || typeof el === 'string' ? { $el: el } : el();
            if (core.isDOM(node) || core.isComponent(node)) {
                if (!node.meta) {
                    node.meta = { section };
                }
                if (children.length && !node.children) {
                    node.children = [
                        ...children.map((child) => typeof child === 'function' ? child(extensions) : child),
                    ];
                }
                if (core.isDOM(node)) {
                    node.attrs = {
                        class: `$classes.${section}`,
                        ...(node.attrs || {}),
                    };
                }
            }
            return {
                if: `$slots.${section}`,
                then: `$slots.${section}`,
                else: section in extensions
                    ? extendSchema(node, extensions[section])
                    : node,
            };
        };
        extendable._s = section;
        return fragment ? createRoot(extendable) : extendable;
    };
}
/**
 * Returns an extendable schema root node.
 *
 * @param rootSection - Creates the root node.
 *
 * @returns {@link @formkit/core#FormKitExtendableSchemaRoot | FormKitExtendableSchemaRoot}
 *
 * @internal
 */
/*@__NO_SIDE_EFFECTS__*/
function createRoot(rootSection) {
    return (extensions) => {
        return [rootSection(extensions)];
    };
}
/**
 * Type guard for schema objects.
 *
 * @param schema - returns `true` if the node is a schema node but not a string
 * or conditional.
 *
 * @returns `boolean`
 *
 * @public
 */
function isSchemaObject(schema) {
    return (typeof schema === 'object' &&
        ('$el' in schema || '$cmp' in schema || '$formkit' in schema));
}
/**
 * Extends a single schema node with an extension. The extension can be any
 * partial node including strings.
 *
 * @param schema - The base schema node.
 * @param extension - The values to extend on the base schema node.
 *
 * @returns {@link @formkit/core#FormKitSchemaNode | FormKitSchemaNode}
 *
 * @public
 */
/*@__NO_SIDE_EFFECTS__*/
function extendSchema(schema, extension = {}) {
    if (typeof schema === 'string') {
        return isSchemaObject(extension) || typeof extension === 'string'
            ? extension
            : schema;
    }
    else if (Array.isArray(schema)) {
        return isSchemaObject(extension) ? extension : schema;
    }
    return utils.extend(schema, extension);
}

/**
 * Actions section that shows the action buttons
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const actions = createSection('actions', () => ({
    $el: 'div',
    if: '$actions',
}));

/**
 * Box section used for grouping options
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const box = createSection('input', () => ({
    $el: 'input',
    bind: '$attrs',
    attrs: {
        type: '$type',
        name: '$node.props.altName || $node.name',
        disabled: '$option.attrs.disabled || $disabled',
        onInput: '$handlers.toggleChecked',
        checked: '$fns.eq($_value, $onValue)',
        onBlur: '$handlers.blur',
        value: '$: true',
        id: '$id',
        'aria-describedby': {
            if: '$options.length',
            then: {
                if: '$option.help',
                then: '$: "help-" + $option.attrs.id',
                else: undefined,
            },
            else: {
                if: '$help',
                then: '$: "help-" + $id',
                else: undefined,
            },
        },
    },
}));

/**
 * Option help section
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const boxHelp = createSection('optionHelp', () => ({
    $el: 'div',
    if: '$option.help',
    attrs: {
        id: '$: "help-" + $option.attrs.id',
    },
}));

/**
 * Box Inner section
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const boxInner = createSection('inner', 'span');

/**
 * Label section for options
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const boxLabel = createSection('label', 'span');

/**
 * Option section used to show an option
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const boxOption = createSection('option', () => ({
    $el: 'li',
    for: ['option', '$options'],
    attrs: {
        'data-disabled': '$option.attrs.disabled || $disabled',
    },
}));

/**
 * Options section used to wrap all option sections in a list
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const boxOptions = createSection('options', 'ul');

/**
 * Wrapper section for options
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const boxWrapper = createSection('wrapper', () => ({
    $el: 'label',
    attrs: {
        'data-disabled': {
            if: '$options.length',
            then: undefined,
            else: '$disabled || undefined',
        },
        'data-checked': {
            if: '$options == undefined',
            then: '$fns.eq($_value, $onValue) || undefined',
            else: '$fns.isChecked($option.value) || undefined',
        },
    },
}));

/**
 * Input section for a button
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const buttonInput = createSection('input', () => ({
    $el: 'button',
    bind: '$attrs',
    attrs: {
        type: '$type',
        disabled: '$disabled',
        name: '$node.name',
        id: '$id',
    },
}));

/**
 * Default section for a button
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const buttonLabel = createSection('default', null);

/**
 * Decorator section
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const decorator = createSection('decorator', () => ({
    $el: 'span',
    attrs: {
        'aria-hidden': 'true',
    },
}));

/**
 * Fieldset section, used to describe help
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const fieldset = createSection('fieldset', () => ({
    $el: 'fieldset',
    attrs: {
        id: '$id',
        'aria-describedby': {
            if: '$help',
            then: '$: "help-" + $id',
            else: undefined,
        },
    },
}));

/**
 * Input section for a file input
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const fileInput = createSection('input', () => ({
    $el: 'input',
    bind: '$attrs',
    attrs: {
        type: 'file',
        disabled: '$disabled',
        name: '$node.name',
        onChange: '$handlers.files',
        onBlur: '$handlers.blur',
        id: '$id',
        'aria-describedby': '$describedBy',
        'aria-required': '$state.required || undefined',
    },
}));

/**
 * File item section for showing a file name
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const fileItem = createSection('fileItem', () => ({
    $el: 'li',
    for: ['file', '$value'],
}));

/**
 * File list section to show all file names
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const fileList = createSection('fileList', () => ({
    $el: 'ul',
    if: '$value.length',
    attrs: {
        'data-has-multiple': '$_hasMultipleFiles',
    },
}));

/**
 * File name section to show the file name
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const fileName = createSection('fileName', () => ({
    $el: 'span',
    attrs: {
        class: '$classes.fileName',
    },
}));

/**
 * File remove section to show a remove button for files
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const fileRemove = createSection('fileRemove', () => ({
    $el: 'button',
    attrs: {
        type: 'button',
        onClick: '$handlers.resetFiles',
    },
}));

/**
 * Form section
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const formInput = createSection('form', () => ({
    $el: 'form',
    bind: '$attrs',
    attrs: {
        id: '$id',
        name: '$node.name',
        onSubmit: '$handlers.submit',
        'data-loading': '$state.loading || undefined',
    },
}));

/**
 * A simple fragment section
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const fragment = createSection('wrapper', null, true);

/**
 * Help section that shows help text
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const help = createSection('help', () => ({
    $el: 'div',
    if: '$help',
    attrs: {
        id: '$: "help-" + $id',
    },
}));

/**
 * Icon section used by all icons
 *
 * @public
 */
const icon = (sectionKey, el) => {
    return createSection(`${sectionKey}Icon`, () => {
        const rawIconProp = `_raw${sectionKey
            .charAt(0)
            .toUpperCase()}${sectionKey.slice(1)}Icon`;
        return {
            if: `$${sectionKey}Icon && $${rawIconProp}`,
            $el: `${el ? el : 'span'}`,
            attrs: {
                class: `$classes.${sectionKey}Icon + " " + $classes.icon`,
                innerHTML: `$${rawIconProp}`,
                onClick: `$handlers.iconClick(${sectionKey})`,
                for: {
                    if: `${el === 'label'}`,
                    then: '$id',
                },
            },
        };
    })();
};

/**
 * Inner section
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const inner = createSection('inner', 'div');

/**
 * Label section with label element
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const label = createSection('label', () => ({
    $el: 'label',
    if: '$label',
    attrs: {
        for: '$id',
    },
}));

/**
 * Legend section, used instead of label when its grouping fields.
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const legend = createSection('legend', () => ({
    $el: 'legend',
    if: '$label',
}));

/**
 * Message section, shows a group of messages.
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const message = createSection('message', () => ({
    $el: 'li',
    for: ['message', '$messages'],
    attrs: {
        key: '$message.key',
        id: `$id + '-' + $message.key`,
        'data-message-type': '$message.type',
    },
}));

/**
 * Messages section where all messages will be displayed.
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const messages = createSection('messages', () => ({
    $el: 'ul',
    if: '$defaultMessagePlacement && $fns.length($messages)',
}));

/**
 * No file section that shows when there is no files
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const noFiles = createSection('noFiles', () => ({
    $el: 'span',
    if: '$value.length == 0',
}));

/**
 * Option section used to show options
 *
 * @public
 */
const optGroup = createSection('optGroup', () => ({
    $el: 'optgroup',
    bind: '$option.attrs',
    attrs: {
        label: '$option.group',
    },
}));

/**
 * Option section used to show options
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const option = createSection('option', () => ({
    $el: 'option',
    bind: '$option.attrs',
    attrs: {
        class: '$classes.option',
        value: '$option.value',
        selected: '$fns.isSelected($option)',
    },
}));

/**
 * Options slot section that displays options when used with slots
 *
 * @public
 */
const optionSlot = createSection('options', () => ({
    $el: null,
    if: '$options.length',
    for: ['option', '$option.options || $options'],
}));

/**
 * Outer section where most data attributes are assigned.
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const outer = createSection('outer', () => ({
    $el: 'div',
    attrs: {
        key: '$id',
        'data-family': '$family || undefined',
        'data-type': '$type',
        'data-multiple': '$attrs.multiple || ($type != "select" && $options != undefined) || undefined',
        'data-has-multiple': '$_hasMultipleFiles',
        'data-disabled': '$: ($disabled !== "false" && $disabled) || undefined',
        'data-empty': '$state.empty || undefined',
        'data-complete': '$state.complete || undefined',
        'data-invalid': '$state.valid === false && $state.validationVisible || undefined',
        'data-errors': '$state.errors || undefined',
        'data-submitted': '$state.submitted || undefined',
        'data-prefix-icon': '$_rawPrefixIcon !== undefined || undefined',
        'data-suffix-icon': '$_rawSuffixIcon !== undefined || undefined',
        'data-prefix-icon-click': '$onPrefixIconClick !== undefined || undefined',
        'data-suffix-icon-click': '$onSuffixIconClick !== undefined || undefined',
    },
}));

/**
 * Prefix section
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const prefix = createSection('prefix', null);

/**
 * Input section used by selects
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const selectInput$1 = createSection('input', () => ({
    $el: 'select',
    bind: '$attrs',
    attrs: {
        id: '$id',
        'data-placeholder': '$fns.showPlaceholder($_value, $placeholder)',
        disabled: '$disabled',
        class: '$classes.input',
        name: '$node.name',
        onChange: '$handlers.onChange',
        onInput: '$handlers.selectInput',
        onBlur: '$handlers.blur',
        'aria-describedby': '$describedBy',
        'aria-required': '$state.required || undefined',
    },
}));

/**
 * Submit section that displays a submit button from a form
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const submitInput = createSection('submit', () => ({
    $cmp: 'FormKit',
    bind: '$submitAttrs',
    props: {
        type: 'submit',
        disabled: '$disabled',
        label: '$submitLabel',
    },
}));

/**
 * Suffix section
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const suffix = createSection('suffix', null);

/**
 * Input section
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const textInput = createSection('input', () => ({
    $el: 'input',
    bind: '$attrs',
    attrs: {
        type: '$type',
        disabled: '$disabled',
        name: '$node.name',
        onInput: '$handlers.DOMInput',
        onBlur: '$handlers.blur',
        value: '$_value',
        id: '$id',
        'aria-describedby': '$describedBy',
        'aria-required': '$state.required || undefined',
    },
}));

/**
 * Input section used by textarea inputs
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const textareaInput = createSection('input', () => ({
    $el: 'textarea',
    bind: '$attrs',
    attrs: {
        disabled: '$disabled',
        name: '$node.name',
        onInput: '$handlers.DOMInput',
        onBlur: '$handlers.blur',
        value: '$_value',
        id: '$id',
        'aria-describedby': '$describedBy',
        'aria-required': '$state.required || undefined',
    },
    children: '$initialValue',
}));

/**
 * Wrapper input section
 *
 * @public
 * @__NO_SIDE_EFFECTS__
 */
const wrapper = createSection('wrapper', 'div');

/**
 * A feature that normalizes box types (checkboxes, radios).
 *
 * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
 *
 * @returns A {@link @formkit/node#FormKitMiddleware | FormKitMiddleware}.
 *
 * @public
 */
function normalizeBoxes(node) {
    return function (prop, next) {
        if (prop.prop === 'options' && Array.isArray(prop.value)) {
            prop.value = prop.value.map((option) => {
                var _a;
                if (!((_a = option.attrs) === null || _a === void 0 ? void 0 : _a.id)) {
                    return utils.extend(option, {
                        attrs: {
                            id: `${node.props.id}-option-${utils.slugify(String(option.value))}`,
                        },
                    });
                }
                return option;
            });
            if (node.props.type === 'checkbox' && !Array.isArray(node.value)) {
                if (node.isCreated) {
                    node.input([], false);
                }
                else {
                    node.on('created', () => {
                        if (!Array.isArray(node.value)) {
                            node.input([], false);
                        }
                    });
                }
            }
        }
        return next(prop);
    };
}

/**
 * Event handler when an input is toggled.
 *
 * @param node - The {@link @formkit/node#FormKitNode | FormKitNode} being toggled.
 * @param e - The input event related to the toggling.
 *
 * @public
 */
function toggleChecked$1(node, e) {
    const el = e.target;
    if (el instanceof HTMLInputElement) {
        const value = Array.isArray(node.props.options)
            ? optionValue(node.props.options, el.value)
            : el.value;
        if (Array.isArray(node.props.options) && node.props.options.length) {
            if (!Array.isArray(node._value)) {
                // There is no array value set
                node.input([value]);
            }
            else if (!node._value.some((existingValue) => shouldSelect(value, existingValue))) {
                // The value is not in the current set
                node.input([...node._value, value]);
            }
            else {
                // Filter out equivalent values
                node.input(node._value.filter((existingValue) => !shouldSelect(value, existingValue)));
            }
        }
        else {
            if (el.checked) {
                node.input(node.props.onValue);
            }
            else {
                node.input(node.props.offValue);
            }
        }
    }
}
/**
 * Checks if a given option is present in the node value.
 *
 * @param node - The The {@link @formkit/node#FormKitNode | FormKitNode} being checked.
 * @param value - The value of any option.
 *
 * @returns `boolean`
 *
 * @public
 */
function isChecked$1(node, value) {
    var _a, _b;
    // We need to force vue’s reactivity to respond when the value is run:
    (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;
    (_b = node.context) === null || _b === void 0 ? void 0 : _b._value;
    if (Array.isArray(node._value)) {
        return node._value.some((existingValue) => shouldSelect(optionValue(node.props.options, value), existingValue));
    }
    return false;
}
/**
 * A feature that adds checkbox selection support.
 *
 * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
 *
 * @public
 */
function checkboxes(node) {
    node.on('created', () => {
        var _a, _b;
        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {
            node.context.handlers.toggleChecked = toggleChecked$1.bind(null, node);
        }
        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.fns) {
            node.context.fns.isChecked = isChecked$1.bind(null, node);
        }
        // Configure our default onValue and offValue
        if (!utils.has(node.props, 'onValue'))
            node.props.onValue = true;
        if (!utils.has(node.props, 'offValue'))
            node.props.offValue = false;
    });
    node.hook.prop(normalizeBoxes(node));
}

/**
 * Adds icon props definition.
 *
 * @param sectionKey - the location the icon should be loaded.
 * @param defaultIcon - the icon that should be loaded if a match is found in the user's CSS.
 *
 * @returns A {@link @formkit/core#FormKitPlugin | FormKitPlugin}.
 *
 * @public
 */
function  defaultIcon(sectionKey, defaultIcon) {
    return (node) => {
        if (node.props[`${sectionKey}Icon`] === undefined) {
            node.props[`${sectionKey}Icon`] = defaultIcon.startsWith('<svg')
                ? defaultIcon
                : `default:${defaultIcon}`;
        }
    };
}

/**
 * A feature that allows disabling children of this node.
 *
 * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
 *
 * @public
 */
function disables(node) {
    node.on('created', () => {
        // If the disabled prop belongs to this *actual* node (not inherited), then
        // perform an `undefine` on it, if not then we'll let the prop be inherited.
        if ('disabled' in node.props) {
            node.props.disabled = utils.undefine(node.props.disabled);
            node.config.disabled = utils.undefine(node.props.disabled);
        }
    });
    node.hook.prop(({ prop, value }, next) => {
        value = prop === 'disabled' ? utils.undefine(value) : value;
        return next({ prop, value });
    });
    node.on('prop:disabled', ({ payload: value }) => {
        node.config.disabled = utils.undefine(value);
    });
}

/**
 * Creates a new feature that generates a localization message of type ui
 * for use on a given component.
 *
 * @param key - The key of the message.
 * @param value - The value of the message.
 *
 * @returns A {@link @formkit/core#FormKitPlugin | FormKitPlugin}.
 *
 * @public
 */
function localize(key, value) {
    return (node) => {
        node.store.set(core.createMessage({
            key,
            type: 'ui',
            value: value || key,
            meta: {
                localize: true,
                i18nArgs: [node],
            },
        }));
    };
}

const isBrowser = typeof window !== 'undefined';
/**
 * Remove the data-file-hover attribute from the target.
 *
 * @param e - Event
 *
 * @internal
 */
function removeHover(e) {
    if (e.target instanceof HTMLElement &&
        e.target.hasAttribute('data-file-hover')) {
        e.target.removeAttribute('data-file-hover');
    }
}
/**
 * Prevent stray drag/drop events from navigating the window.
 *
 * @param e - Event
 *
 * @internal
 */
function preventStrayDrop(type, e) {
    if (!(e.target instanceof HTMLInputElement)) {
        e.preventDefault();
    }
    else if (type === 'dragover') {
        e.target.setAttribute('data-file-hover', 'true');
    }
    if (type === 'drop') {
        removeHover(e);
    }
}
/**
 * A feature to add file handling support to an input.
 *
 * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
 *
 * @public
 */
function files(node) {
    // Localize our content:
    localize('noFiles', 'Select file')(node);
    localize('removeAll', 'Remove all')(node);
    localize('remove')(node);
    node.addProps(['_hasMultipleFiles']);
    if (isBrowser) {
        if (!window._FormKit_File_Drop) {
            window.addEventListener('dragover', preventStrayDrop.bind(null, 'dragover'));
            window.addEventListener('drop', preventStrayDrop.bind(null, 'drop'));
            window.addEventListener('dragleave', removeHover);
            window._FormKit_File_Drop = true;
        }
    }
    node.hook.input((value, next) => next(Array.isArray(value) ? value : []));
    node.on('input', ({ payload: value }) => {
        node.props._hasMultipleFiles =
            Array.isArray(value) && value.length > 1 ? true : undefined;
    });
    node.on('reset', () => {
        if (node.props.id && isBrowser) {
            const el = document.getElementById(node.props.id);
            if (el)
                el.value = '';
        }
    });
    node.on('created', () => {
        if (!Array.isArray(node.value))
            node.input([], false);
        if (!node.context)
            return;
        node.context.handlers.resetFiles = (e) => {
            e.preventDefault();
            node.input([]);
            if (node.props.id && isBrowser) {
                const el = document.getElementById(node.props.id);
                if (el)
                    el.value = '';
                el === null || el === void 0 ? void 0 : el.focus();
            }
        };
        node.context.handlers.files = (e) => {
            var _a, _b;
            const files = [];
            if (e.target instanceof HTMLInputElement && e.target.files) {
                for (let i = 0; i < e.target.files.length; i++) {
                    let file;
                    if ((file = e.target.files.item(i))) {
                        files.push({ name: file.name, file });
                    }
                }
                node.input(files);
            }
            if (node.context)
                node.context.files = files;
            // Call the original listener if there is one.
            if (typeof ((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.onChange) === 'function') {
                (_b = node.props.attrs) === null || _b === void 0 ? void 0 : _b.onChange(e);
            }
        };
    });
}

const loading = core.createMessage({
    key: 'loading',
    value: true,
    visible: false,
});
/**
 * Handle the submit event.
 *
 * @param e - The event
 *
 * @internal
 */
async function handleSubmit(node, submitEvent) {
    const submitNonce = Math.random();
    node.props._submitNonce = submitNonce;
    submitEvent.preventDefault();
    await node.settled;
    if (node.ledger.value('validating')) {
        // There are validation rules still pending.
        node.store.set(loading);
        await node.ledger.settled('validating');
        node.store.remove('loading');
        // If this was not the same submit event, bail out.
        if (node.props._submitNonce !== submitNonce)
            return;
    }
    // Set the submitted state on all children
    const setSubmitted = (n) => n.store.set(core.createMessage({
        key: 'submitted',
        value: true,
        visible: false,
    }));
    node.walk(setSubmitted);
    setSubmitted(node);
    node.emit('submit-raw');
    if (typeof node.props.onSubmitRaw === 'function') {
        node.props.onSubmitRaw(submitEvent, node);
    }
    if (node.ledger.value('blocking')) {
        if (typeof node.props.onSubmitInvalid === 'function') {
            node.props.onSubmitInvalid(node);
        }
        // There is still a blocking message in the store.
        if (node.props.incompleteMessage !== false) {
            setIncompleteMessage(node);
        }
    }
    else {
        // No blocking messages
        if (typeof node.props.onSubmit === 'function') {
            // call onSubmit
            const retVal = node.props.onSubmit(node.hook.submit.dispatch(utils.clone(node.value)), node);
            if (retVal instanceof Promise) {
                const autoDisable = node.props.disabled === undefined &&
                    node.props.submitBehavior !== 'live';
                if (autoDisable)
                    node.props.disabled = true;
                node.store.set(loading);
                await retVal;
                if (autoDisable)
                    node.props.disabled = false;
                node.store.remove('loading');
            }
        }
        else {
            if (submitEvent.target instanceof HTMLFormElement) {
                submitEvent.target.submit();
            }
        }
    }
}
/**
 * Set the incomplete message on a specific node.
 * @param node - The node to set the incomplete message on.
 */
function setIncompleteMessage(node) {
    node.store.set(core.createMessage({
        blocking: false,
        key: `incomplete`,
        meta: {
            localize: node.props.incompleteMessage === undefined,
            i18nArgs: [{ node }],
            showAsMessage: true,
        },
        type: 'ui',
        value: node.props.incompleteMessage || 'Form incomplete.',
    }));
}
/**
 * A feature to add a submit handler and actions section.
 *
 * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
 *
 * @public
 */
function form$1(node) {
    node.props.isForm = true;
    node.ledger.count('validating', (m) => m.key === 'validating');
    node.on('created', () => {
        var _a;
        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {
            node.context.handlers.submit = handleSubmit.bind(null, node);
        }
        if (!utils.has(node.props, 'actions')) {
            node.props.actions = true;
        }
    });
    node.on('prop:incompleteMessage', () => {
        if (node.store.incomplete)
            setIncompleteMessage(node);
    });
    node.on('settled:blocking', () => node.store.remove('incomplete'));
}

/**
 * A feature that applies `ignore="true"` by default.
 *
 * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
 *
 * @public
 */
function ignore(node) {
    if (node.props.ignore === undefined) {
        node.props.ignore = true;
        node.parent = null;
    }
}

/**
 * A feature that ensures the input has an `initialValue` prop.
 *
 * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
 *
 * @public
 */
function initialValue(node) {
    node.on('created', () => {
        if (node.context) {
            node.context.initialValue = node.value || '';
        }
    });
}

/**
 * A feature that allows casting to numbers.
 *
 * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
 *
 * @public
 */
function casts(node) {
    if (typeof node.props.number === 'undefined')
        return;
    const strict = ['number', 'range', 'hidden'].includes(node.props.type);
    node.hook.input((value, next) => {
        if (value === '')
            return next(undefined);
        const numericValue = node.props.number === 'integer' ? parseInt(value) : parseFloat(value);
        if (!Number.isFinite(numericValue))
            return strict ? next(undefined) : next(value);
        return next(numericValue);
    });
}

/**
 * Sets the value of a radio button when checked.
 *
 * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
 * @param event - Event
 *
 * @public
 */
function toggleChecked(node, event) {
    if (event.target instanceof HTMLInputElement) {
        node.input(optionValue(node.props.options, event.target.value));
    }
}
/**
 * Checks if the value being checked is the current value.
 *
 * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
 * @param value - The value to check
 *
 * @returns `boolean`
 *
 * @public
 */
function isChecked(node, value) {
    var _a, _b;
    // We need to force vue’s reactivity to respond when the value is run:
    (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;
    (_b = node.context) === null || _b === void 0 ? void 0 : _b._value;
    return shouldSelect(optionValue(node.props.options, value), node._value);
}
/**
 * A feature to check if the value being checked is the current value.
 *
 * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.
 *
 * @public
 */
function radios(node) {
    node.on('created', () => {
        var _a, _b;
        if (!Array.isArray(node.props.options)) {
            core.warn(350, {
                node,
                inputType: 'radio',
            });
        }
        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {
            node.context.handlers.toggleChecked = toggleChecked.bind(null, node);
        }
        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.fns) {
            node.context.fns.isChecked = isChecked.bind(null, node);
        }
    });
    node.hook.prop(normalizeBoxes(node));
}

/**
 * A simple counter to keep track of how many radios have been placed.
 */
let radioInstance = 0;
/**
 * Automatically rename any radio inputs.
 * @param node - A formkit node.
 * @returns
 */
function renamesRadios(node) {
    if (node.type === 'group' || node.type === 'list') {
        node.plugins.add(renamesRadiosPlugin);
    }
}
function renamesRadiosPlugin(node) {
    if (node.props.type === 'radio') {
        node.addProps(['altName']);
        node.props.altName = `${node.name}_${radioInstance++}`;
    }
}

/**
 * Checks if a the given option should have the selected attribute.
 * @param node - The node being evaluated.
 * @param option - The option value to check
 * @returns
 * @public
 */
function isSelected(node, option) {
    if (isGroupOption(option))
        return false;
    // Here we trick reactivity (if at play) to watch this function.
    node.context && node.context.value;
    const optionValue = '__original' in option ? option.__original : option.value;
    return Array.isArray(node._value)
        ? node._value.some((optionA) => shouldSelect(optionA, optionValue))
        : (node._value === undefined ||
            (node._value === null && !containsValue(node.props.options, null))) &&
            option.attrs &&
            option.attrs['data-is-placeholder']
            ? true
            : shouldSelect(optionValue, node._value);
}
/**
 * Checks to see if a given value is anywhere in the options list.
 */
function containsValue(options, value) {
    return options.some((option) => {
        if (isGroupOption(option)) {
            return containsValue(option.options, value);
        }
        else {
            return (('__original' in option ? option.__original : option.value) === value);
        }
    });
}
/**
 * Defers the change event till after the next cycle.
 * @param node - The node being evaluated.
 * @param e - The change event.
 */
async function deferChange(node, e) {
    var _a;
    if (typeof ((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.onChange) === 'function') {
        await new Promise((r) => setTimeout(r, 0));
        await node.settled;
        node.props.attrs.onChange(e);
    }
}
/**
 * Select the correct values.
 * @param e - The input event emitted by the select.
 */
function  selectInput(node, e) {
    const target = e.target;
    const value = target.hasAttribute('multiple')
        ? Array.from(target.selectedOptions).map((o) => optionValue(node.props.options, o.value))
        : optionValue(node.props.options, target.value);
    node.input(value);
}
/**
 * Appends a placeholder to the options list.
 * @param options - An options list
 * @param placeholder - A placeholder string to append
 * @returns
 */
function applyPlaceholder(options, placeholder) {
    if (!options.some((option) => option.attrs && option.attrs['data-is-placeholder'])) {
        return [
            {
                label: placeholder,
                value: '',
                attrs: {
                    hidden: true,
                    disabled: true,
                    'data-is-placeholder': 'true',
                },
            },
            ...options,
        ];
    }
    return options;
}
/**
 * Given an options list, find the first true value.
 * @param options - An options list (with groups)
 */
function firstValue(options) {
    const option = options.length > 0 ? options[0] : undefined;
    if (!option)
        return undefined;
    if (isGroupOption(option))
        return firstValue(option.options);
    return '__original' in option ? option.__original : option.value;
}
/**
 * Converts the options prop to usable values.
 * @param node - A formkit node.
 * @public
 */
function select$1(node) {
    // Set the initial value of a multi-input
    node.on('created', () => {
        var _a, _b, _c;
        const isMultiple = utils.undefine((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.multiple);
        if (!isMultiple &&
            node.props.placeholder &&
            Array.isArray(node.props.options)) {
            node.hook.prop(({ prop, value }, next) => {
                if (prop === 'options') {
                    value = applyPlaceholder(value, node.props.placeholder);
                }
                return next({ prop, value });
            });
            node.props.options = applyPlaceholder(node.props.options, node.props.placeholder);
        }
        if (isMultiple) {
            if (node.value === undefined) {
                node.input([], false);
            }
        }
        else if (node.context && !node.context.options) {
            // If this input is (probably) using the default slot, we need to add a
            // "value" attribute to get bound
            node.props.attrs = Object.assign({}, node.props.attrs, {
                value: node._value,
            });
            node.on('input', ({ payload }) => {
                node.props.attrs = Object.assign({}, node.props.attrs, {
                    value: payload,
                });
            });
        }
        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.handlers) {
            node.context.handlers.selectInput = selectInput.bind(null, node);
            node.context.handlers.onChange = deferChange.bind(null, node);
        }
        if ((_c = node.context) === null || _c === void 0 ? void 0 : _c.fns) {
            node.context.fns.isSelected = isSelected.bind(null, node);
            node.context.fns.showPlaceholder = (value, placeholder) => {
                if (!Array.isArray(node.props.options))
                    return false;
                const hasMatchingValue = node.props.options.some((option) => {
                    if (option.attrs && 'data-is-placeholder' in option.attrs)
                        return false;
                    const optionValue = '__original' in option ? option.__original : option.value;
                    return utils.eq(value, optionValue);
                });
                return placeholder && !hasMatchingValue ? true : undefined;
            };
        }
    });
    node.hook.input((value, next) => {
        var _a, _b, _c;
        if (!node.props.placeholder &&
            value === undefined &&
            Array.isArray((_a = node.props) === null || _a === void 0 ? void 0 : _a.options) &&
            node.props.options.length &&
            !utils.undefine((_c = (_b = node.props) === null || _b === void 0 ? void 0 : _b.attrs) === null || _c === void 0 ? void 0 : _c.multiple)) {
            value = firstValue(node.props.options);
        }
        return next(value);
    });
}

/**
 * Checks if the current schema node is a slot condition.
 *
 * @example
 *
 * ```js
 * {
 *  if: '$slot.name',
 *  then: '$slot.name',
 *  else: []
 * } // this schema node would return true.
 * ```
 *
 * @param node - A {@link @formkit/core#FormKitSchemaNode | FormKitSchemaNode}.
 *
 * @returns `boolean`
 *
 * @public
 */
/*@__NO_SIDE_EFFECTS__*/
function isSlotCondition(node) {
    if (core.isConditional(node) &&
        node.if &&
        node.if.startsWith('$slots.') &&
        typeof node.then === 'string' &&
        node.then.startsWith('$slots.') &&
        'else' in node) {
        return true;
    }
    return false;
}
/**
 * Finds a seciton by name in a schema.
 *
 * @param schema - A {@link @formkit/core#FormKitSchemaDefinition | FormKitSchemaDefinition} array.
 * @param target - The name of the section to find.
 *
 * @returns a tuple of the schema and the section or a tuple of `false` and `false` if not found.
 *
 * @public
 */
/*@__NO_SIDE_EFFECTS__*/
function findSection(schema, target) {
    var _a;
    return ((_a = eachSection(schema, (section, parent, schemaCondition) => {
        var _a;
        if (((_a = section.meta) === null || _a === void 0 ? void 0 : _a.section) === target) {
            return [parent, schemaCondition];
        }
        return;
    }, true)) !== null && _a !== void 0 ? _a : [false, false]);
}
/**
 * Runs a callback over every section in a schema. if stopOnCallbackReturn is true
 * and the callback returns a value, the loop will stop and return that value.
 *
 * @param schema - A {@link @formkit/core#FormKitSchemaNode | FormKitSchemaNode} array.
 * @param callback - A callback to run on every section.
 * @param stopOnCallbackReturn - If true, the loop will stop if the callback returns a value.
 * @param schemaParent - The parent of the current schema node.
 *
 * @returns
 *
 * @public
 */
/*@__NO_SIDE_EFFECTS__*/
function eachSection(schema, callback, stopOnCallbackReturn = false, schemaParent = []) {
    if (Array.isArray(schema)) {
        for (const section of schema) {
            const callbackReturn = eachSection(section, callback, stopOnCallbackReturn, schema);
            if (callbackReturn && stopOnCallbackReturn) {
                return callbackReturn;
            }
        }
        return;
    }
    if (isSlotCondition(schema)) {
        if (core.isComponent(schema.else) || core.isDOM(schema.else)) {
            if (schema.else.meta) {
                const callbackReturn = callback(schema.else, schemaParent, schema);
                if (callbackReturn && stopOnCallbackReturn) {
                    return callbackReturn;
                }
            }
            if (schema.else.children &&
                Array.isArray(schema.else.children) &&
                schema.else.children.length) {
                return eachSection(schema.else.children, callback, stopOnCallbackReturn, schemaParent);
            }
        }
    }
}
/**
 * Creates an input schema with all of the wrapping base schema.
 *
 * @param inputSection - Content to store in the input section key location.
 *
 * @returns {@link @formkit/core#FormKitExtendableSchemaRoot | FormKitExtendableSchemaRoot}
 *
 * @public
 */
/*@__NO_SIDE_EFFECTS__*/
function useSchema(inputSection) {
    return /* #__PURE__ */ outer(/* #__PURE__ */ wrapper(/* #__PURE__ */ label('$label'), /* #__PURE__ */ inner(/* #__PURE__ */ icon('prefix'), /* #__PURE__ */ prefix(), inputSection(), /* #__PURE__ */ suffix(), /* #__PURE__ */ icon('suffix'))), /* #__PURE__ */ help('$help'), /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value')));
}
// ========================================================
/**
 * Applies attributes to a given schema section by applying a higher order
 * function that merges a given set of attributes into the node.
 *
 * @param attrs - Attributes to apply to a {@link FormKitSchemaExtendableSection
 * | FormKitSchemaExtendableSection}.
 * @param section - A section to apply attributes to.
 *
 * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}
 *
 * @public
 */
/*@__NO_SIDE_EFFECTS__*/
function  $attrs(attrs, section) {
    const extendable = (extensions) => {
        const node = section(extensions);
        const attributes = typeof attrs === 'function' ? attrs() : attrs;
        if (!utils.isObject(attributes))
            return node;
        if (isSlotCondition(node) && core.isDOM(node.else)) {
            node.else.attrs = { ...node.else.attrs, ...attributes };
        }
        else if (core.isDOM(node)) {
            node.attrs = { ...node.attrs, ...attributes };
        }
        return node;
    };
    extendable._s = section._s;
    return extendable;
}
/**
 * Applies a condition to a given schema section.
 *
 * @param condition - A schema condition to apply to a section.
 * @param then - The section that applies if the condition is true.
 * @param otherwise - (else) The section that applies if the condition is false.
 *
 * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}
 *
 * @public
 */
/*@__NO_SIDE_EFFECTS__*/
function  $if(condition, then, otherwise) {
    const extendable = (extensions) => {
        const node = then(extensions);
        if (otherwise ||
            (isSchemaObject(node) && 'if' in node) ||
            isSlotCondition(node)) {
            const conditionalNode = {
                if: condition,
                then: node,
            };
            if (otherwise) {
                conditionalNode.else = otherwise(extensions);
            }
            return conditionalNode;
        }
        else if (isSlotCondition(node)) {
            Object.assign(node.else, { if: condition });
        }
        else if (isSchemaObject(node)) {
            Object.assign(node, { if: condition });
        }
        return node;
    };
    extendable._s = utils.token();
    return extendable;
}
/**
 * Applies a condition to a given schema section.
 *
 * @param varName - The name of the variable that holds the current instance.
 * @param inName - The variable we are iterating over.
 * @param section - A section to repeat.
 *
 * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}
 *
 * @public
 */
/*@__NO_SIDE_EFFECTS__*/
function  $for(varName, inName, section) {
    return (extensions) => {
        const node = section(extensions);
        if (isSlotCondition(node)) {
            Object.assign(node.else, { for: [varName, inName] });
        }
        else if (isSchemaObject(node)) {
            Object.assign(node, { for: [varName, inName] });
        }
        return node;
    };
}
/**
 * Extends a schema node with a given set of extensions.
 *
 * @param section - A section to apply an extension to.
 * @param extendWith - A partial schema snippet to apply to the section.
 *
 * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}
 *
 * @public
 */
/*@__NO_SIDE_EFFECTS__*/
function  $extend(section, extendWith) {
    const extendable = (extensions) => {
        const node = section({});
        if (isSlotCondition(node)) {
            if (Array.isArray(node.else))
                return node;
            node.else = extendSchema(extendSchema(node.else, extendWith), section._s ? extensions[section._s] : {});
            return node;
        }
        return extendSchema(extendSchema(node, extendWith), section._s ? extensions[section._s] : {});
    };
    extendable._s = section._s;
    return extendable;
}
/**
 * Creates a root schema section.
 *
 * @param section - A section to make a root from.
 *
 * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}
 *
 * @public
 */
/*@__NO_SIDE_EFFECTS__*/
function  $root(section) {
    core.warn(800, '$root');
    return createRoot(section);
}

/**
 * Input definition for a button.
 * @public
 */
const button = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* #__PURE__ */ outer(/* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value')), /* #__PURE__ */ wrapper(/* #__PURE__ */ buttonInput(/* #__PURE__ */ icon('prefix'), /* #__PURE__ */ prefix(), /* #__PURE__ */ buttonLabel('$label || $ui.submit.value'), /* #__PURE__ */ suffix(), /* #__PURE__ */ icon('suffix'))), /* #__PURE__ */ help('$help')),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'input',
    /**
     * The family of inputs this one belongs too. For example "text" and "email"
     * are both part of the "text" family. This is primary used for styling.
     */
    family: 'button',
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: [localize('submit'), ignore],
    /**
     * A key to use for memoizing the schema. This is used to prevent the schema
     * from needing to be stringified when performing a memo lookup.
     */
    schemaMemoKey: 'h6st4epl3j8',
};

/**
 * Input definition for a checkbox(ess).
 * @public
 */
const checkbox = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* #__PURE__ */ outer(/* #__PURE__ */ $if('$options == undefined', 
    /**
     * Single checkbox structure.
     */
    /* #__PURE__ */ boxWrapper(/* #__PURE__ */ boxInner(/* #__PURE__ */ prefix(), /* #__PURE__ */ box(), /* #__PURE__ */ decorator(/* #__PURE__ */ icon('decorator')), /* #__PURE__ */ suffix()), /* #__PURE__ */ $extend(/* #__PURE__ */ boxLabel('$label'), {
        if: '$label',
    })), 
    /**
     * Multi checkbox structure.
     */
    /* #__PURE__ */ fieldset(/* #__PURE__ */ legend('$label'), /* #__PURE__ */ help('$help'), /* #__PURE__ */ boxOptions(/* #__PURE__ */ boxOption(/* #__PURE__ */ boxWrapper(/* #__PURE__ */ boxInner(/* #__PURE__ */ prefix(), /* #__PURE__ */ $extend(/* #__PURE__ */ box(), {
        bind: '$option.attrs',
        attrs: {
            id: '$option.attrs.id',
            value: '$option.value',
            checked: '$fns.isChecked($option.value)',
        },
    }), /* #__PURE__ */ decorator(/* #__PURE__ */ icon('decorator')), /* #__PURE__ */ suffix()), /* #__PURE__ */ $extend(/* #__PURE__ */ boxLabel('$option.label'), {
        if: '$option.label',
    })), /* #__PURE__ */ boxHelp('$option.help'))))), 
    // Help text only goes under the input when it is a single.
    /* #__PURE__ */ $if('$options == undefined && $help', /* #__PURE__ */ help('$help')), /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'input',
    /**
     * The family of inputs this one belongs too. For example "text" and "email"
     * are both part of the "text" family. This is primary used for styling.
     */
    family: 'box',
    /**
     * An array of extra props to accept for this input.
     */
    props: ['options', 'onValue', 'offValue', 'optionsLoader'],
    /**
     * Additional features that should be added to your input
     */
    features: [
        options,
        checkboxes,
        /* #__PURE__ */ defaultIcon('decorator', 'checkboxDecorator'),
    ],
    /**
     * The key used to memoize the schema.
     */
    schemaMemoKey: 'qje02tb3gu8',
};

/**
 * Input definition for a file input.
 * @public
 */
const file = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* #__PURE__ */ outer(/* #__PURE__ */ wrapper(/* #__PURE__ */ label('$label'), /* #__PURE__ */ inner(/* #__PURE__ */ icon('prefix', 'label'), /* #__PURE__ */ prefix(), /* #__PURE__ */ fileInput(), /* #__PURE__ */ fileList(/* #__PURE__ */ fileItem(/* #__PURE__ */ icon('fileItem'), /* #__PURE__ */ fileName('$file.name'), /* #__PURE__ */ $if('$value.length === 1', /* #__PURE__ */ fileRemove(/* #__PURE__ */ icon('fileRemove'), '$ui.remove.value + " " + $file.name')))), /* #__PURE__ */ $if('$value.length > 1', /* #__PURE__ */ fileRemove('$ui.removeAll.value')), /* #__PURE__ */ noFiles(/* #__PURE__ */ icon('noFiles'), '$ui.noFiles.value'), /* #__PURE__ */ suffix(), /* #__PURE__ */ icon('suffix'))), /* #__PURE__ */ help('$help'), /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'input',
    /**
     * The family of inputs this one belongs too. For example "text" and "email"
     * are both part of the "text" family. This is primary used for styling.
     */
    family: 'text',
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: [
        files,
        /* #__PURE__ */ defaultIcon('fileItem', 'fileItem'),
        /* #__PURE__ */ defaultIcon('fileRemove', 'fileRemove'),
        /* #__PURE__ */ defaultIcon('noFiles', 'noFiles'),
    ],
    /**
     * The key used to memoize the schema.
     */
    schemaMemoKey: '9kqc4852fv8',
};

/**
 * Input definition for a form.
 * @public
 */
const form = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* #__PURE__ */ formInput('$slots.default', /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value')), /* #__PURE__ */ actions(/* #__PURE__ */ submitInput())),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'group',
    /**
     * An array of extra props to accept for this input.
     */
    props: [
        'actions',
        'submit',
        'submitLabel',
        'submitAttrs',
        'submitBehavior',
        'incompleteMessage',
    ],
    /**
     * Additional features that should be added to your input
     */
    features: [form$1, disables],
    /**
     * The key used to memoize the schema.
     */
    schemaMemoKey: '5bg016redjo',
};

/**
 * Input definition for a group.
 * @public
 */
const group = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* #__PURE__ */ fragment('$slots.default'),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'group',
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: [disables, renamesRadios],
};

/**
 * Input definition for a hidden input.
 * @public
 */
const hidden = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* #__PURE__ */ textInput(),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'input',
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: [casts],
};

/**
 * Input definition for a list.
 * @public
 */
const list = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* #__PURE__ */ fragment('$slots.default'),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'list',
    /**
     * An array of extra props to accept for this input.
     */
    props: ['sync', 'dynamic'],
    /**
     * Additional features that should be added to your input
     */
    features: [disables, renamesRadios],
};

/**
 * Input definition for a meta input.
 * @public
 */
const meta = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* #__PURE__ */ fragment(),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'input',
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: [],
};

/**
 * Input definition for a radio.
 * @public
 */
const radio = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* #__PURE__ */ outer(/* #__PURE__ */ $if('$options == undefined', 
    /**
     * Single radio structure.
     */
    /* #__PURE__ */ boxWrapper(/* #__PURE__ */ boxInner(/* #__PURE__ */ prefix(), /* #__PURE__ */ box(), /* #__PURE__ */ decorator(/* #__PURE__ */ icon('decorator')), /* #__PURE__ */ suffix()), /* #__PURE__ */ $extend(/* #__PURE__ */ boxLabel('$label'), {
        if: '$label',
    })), 
    /**
     * Multi radio structure.
     */
    /* #__PURE__ */ fieldset(/* #__PURE__ */ legend('$label'), /* #__PURE__ */ help('$help'), /* #__PURE__ */ boxOptions(/* #__PURE__ */ boxOption(/* #__PURE__ */ boxWrapper(/* #__PURE__ */ boxInner(/* #__PURE__ */ prefix(), /* #__PURE__ */ $extend(/* #__PURE__ */ box(), {
        bind: '$option.attrs',
        attrs: {
            id: '$option.attrs.id',
            value: '$option.value',
            checked: '$fns.isChecked($option.value)',
        },
    }), /* #__PURE__ */ decorator(/* #__PURE__ */ icon('decorator')), /* #__PURE__ */ suffix()), /* #__PURE__ */ $extend(/* #__PURE__ */ boxLabel('$option.label'), {
        if: '$option.label',
    })), /* #__PURE__ */ boxHelp('$option.help'))))), 
    // Help text only goes under the input when it is a single.
    /* #__PURE__ */ $if('$options == undefined && $help', /* #__PURE__ */ help('$help')), /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'input',
    /**
     * The family of inputs this one belongs too. For example "text" and "email"
     * are both part of the "text" family. This is primary used for styling.
     */
    family: 'box',
    /**
     * An array of extra props to accept for this input.
     */
    props: ['options', 'onValue', 'offValue', 'optionsLoader'],
    /**
     * Additional features that should be added to your input
     */
    features: [options, radios, /* #__PURE__ */ defaultIcon('decorator', 'radioDecorator')],
    /**
     * The key used to memoize the schema.
     */
    schemaMemoKey: 'qje02tb3gu8',
};

/**
 * Input definition for a select.
 * @public
 */
const select = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* #__PURE__ */ outer(/* #__PURE__ */ wrapper(/* #__PURE__ */ label('$label'), /* #__PURE__ */ inner(/* #__PURE__ */ icon('prefix'), /* #__PURE__ */ prefix(), /* #__PURE__ */ selectInput$1(/* #__PURE__ */ $if('$slots.default', () => '$slots.default', /* #__PURE__ */ optionSlot(/* #__PURE__ */ $if('$option.group', /* #__PURE__ */ optGroup(/* #__PURE__ */ optionSlot(/* #__PURE__ */ option('$option.label'))), /* #__PURE__ */ option('$option.label'))))), /* #__PURE__ */ $if('$attrs.multiple !== undefined', () => '', /* #__PURE__ */ icon('select')), /* #__PURE__ */ suffix(), /* #__PURE__ */ icon('suffix'))), /* #__PURE__ */ help('$help'), /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'input',
    /**
     * An array of extra props to accept for this input.
     */
    props: ['options', 'placeholder', 'optionsLoader'],
    /**
     * Additional features that should be added to your input
     */
    features: [options, select$1, /* #__PURE__ */ defaultIcon('select', 'select')],
    /**
     * The key used to memoize the schema.
     */
    schemaMemoKey: 'cb119h43krg',
};

/**
 * Input definition for a textarea.
 * @public
 */
const textarea = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* #__PURE__ */ outer(/* #__PURE__ */ wrapper(/* #__PURE__ */ label('$label'), /* #__PURE__ */ inner(/* #__PURE__ */ icon('prefix', 'label'), /* #__PURE__ */ prefix(), /* #__PURE__ */ textareaInput(), /* #__PURE__ */ suffix(), /* #__PURE__ */ icon('suffix'))), /* #__PURE__ */ help('$help'), /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'input',
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: [initialValue],
    /**
     * The key used to memoize the schema.
     */
    schemaMemoKey: 'b1n0td79m9g',
};

/**
 * Input definition for a text.
 * @public
 */
const text = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* #__PURE__ */ outer(/* #__PURE__ */ wrapper(/* #__PURE__ */ label('$label'), /* #__PURE__ */ inner(/* #__PURE__ */ icon('prefix', 'label'), /* #__PURE__ */ prefix(), /* #__PURE__ */ textInput(), /* #__PURE__ */ suffix(), /* #__PURE__ */ icon('suffix'))), /* #__PURE__ */ help('$help'), /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'input',
    /**
     * The family of inputs this one belongs too. For example "text" and "email"
     * are both part of the "text" family. This is primary used for styling.
     */
    family: 'text',
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: [casts],
    /**
     * The key used to memoize the schema.
     */
    schemaMemoKey: 'c3cc4kflsg',
};

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    button: button,
    checkbox: checkbox,
    color: text,
    date: text,
    datetimeLocal: text,
    email: text,
    file: file,
    form: form,
    group: group,
    hidden: hidden,
    list: list,
    meta: meta,
    month: text,
    number: text,
    password: text,
    radio: radio,
    range: text,
    search: text,
    select: select,
    submit: button,
    tel: text,
    text: text,
    textarea: textarea,
    time: text,
    url: text,
    week: text
});

exports.$attrs = $attrs;
exports.$extend = $extend;
exports.$for = $for;
exports.$if = $if;
exports.$root = $root;
exports.actions = actions;
exports.box = box;
exports.boxHelp = boxHelp;
exports.boxInner = boxInner;
exports.boxLabel = boxLabel;
exports.boxOption = boxOption;
exports.boxOptions = boxOptions;
exports.boxWrapper = boxWrapper;
exports.button = button;
exports.buttonInput = buttonInput;
exports.buttonLabel = buttonLabel;
exports.casts = casts;
exports.checkbox = checkbox;
exports.checkboxes = checkboxes;
exports.color = text;
exports.createLibraryPlugin = createLibraryPlugin;
exports.createSection = createSection;
exports.date = text;
exports.datetimeLocal = text;
exports.decorator = decorator;
exports.defaultIcon = defaultIcon;
exports.disablesChildren = disables;
exports.eachSection = eachSection;
exports.email = text;
exports.extendSchema = extendSchema;
exports.fieldset = fieldset;
exports.file = file;
exports.fileInput = fileInput;
exports.fileItem = fileItem;
exports.fileList = fileList;
exports.fileName = fileName;
exports.fileRemove = fileRemove;
exports.files = files;
exports.findSection = findSection;
exports.form = form;
exports.formInput = formInput;
exports.forms = form$1;
exports.fragment = fragment;
exports.group = group;
exports.help = help;
exports.hidden = hidden;
exports.icon = icon;
exports.ignores = ignore;
exports.initialValue = initialValue;
exports.inner = inner;
exports.inputs = index;
exports.isGroupOption = isGroupOption;
exports.isSchemaObject = isSchemaObject;
exports.isSlotCondition = isSlotCondition;
exports.label = label;
exports.legend = legend;
exports.list = list;
exports.localize = localize;
exports.message = message;
exports.messages = messages;
exports.meta = meta;
exports.month = text;
exports.noFiles = noFiles;
exports.normalizeBoxes = normalizeBoxes;
exports.normalizeOptions = normalizeOptions;
exports.number = text;
exports.optGroup = optGroup;
exports.option = option;
exports.optionSlot = optionSlot;
exports.options = options;
exports.outer = outer;
exports.password = text;
exports.prefix = prefix;
exports.radio = radio;
exports.radios = radios;
exports.range = text;
exports.renamesRadios = renamesRadios;
exports.runtimeProps = runtimeProps;
exports.search = text;
exports.select = select;
exports.selectInput = selectInput$1;
exports.selects = select$1;
exports.submit = button;
exports.submitInput = submitInput;
exports.suffix = suffix;
exports.tel = text;
exports.text = text;
exports.textInput = textInput;
exports.textarea = textarea;
exports.textareaInput = textareaInput;
exports.time = text;
exports.url = text;
exports.useSchema = useSchema;
exports.week = text;
exports.wrapper = wrapper;
