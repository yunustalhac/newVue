import { warn, getNode, watchRegistry, isNode, sugar, isDOM, isComponent as isComponent$1, isConditional, compile, error, createConfig, clearErrors, setErrors, submitForm, reset, createNode, createMessage, createClasses, generateClassList } from '@formkit/core';
export { clearErrors, errorHandler, reset, resetCount, setErrors, submitForm } from '@formkit/core';
import { defineComponent, getCurrentInstance, markRaw, watch, watchEffect, reactive, onUnmounted, ref, isRef, createTextVNode, resolveComponent, h, provide, inject, onMounted, computed, toRef, onBeforeUnmount, KeepAlive, Suspense, nextTick, triggerRef, isReactive } from 'vue';
import { has, isPojo, cloneAny, extend, undefine, camel, kebab, nodeProps, only, except, oncePerTick, slugify, shallowClone, eq, isObject, token, empty } from '@formkit/utils';
import { runtimeProps, createSection, useSchema, localize, createLibraryPlugin, inputs } from '@formkit/inputs';
import * as defaultRules from '@formkit/rules';
import { createValidationPlugin } from '@formkit/validation';
import { createI18nPlugin, en } from '@formkit/i18n';
import { createThemePlugin, createIconHandler } from '@formkit/themes';
import { createObserver } from '@formkit/observer';
import { register } from '@formkit/dev';

/**
 * A flag indicating if this is (likely) a server context.
 */
const isServer$2 = typeof window === 'undefined';
/**
 * A map of Vue applications to a set of callbacks to be flushed after SSR is
 * complete.
 */
const ssrCompleteRegistry = new Map();
/**
 * Flush all callbacks registered with onSSRComplete for a given app.
 * @param app - The Vue application.
 * @public
 */
function ssrComplete(app) {
    if (!isServer$2)
        return;
    const callbacks = ssrCompleteRegistry.get(app);
    if (!callbacks)
        return;
    for (const callback of callbacks) {
        callback();
    }
    callbacks.clear();
    ssrCompleteRegistry.delete(app);
}
/**
 * Register a callback for when SSR is complete. No-op if not in a server
 * context.
 * @param app - The Vue application.
 * @param callback - The callback to be called after SSR is complete.
 * @public
 */
function onSSRComplete(app, callback) {
    var _a;
    if (!isServer$2 || !app)
        return;
    if (!ssrCompleteRegistry.has(app))
        ssrCompleteRegistry.set(app, new Set());
    (_a = ssrCompleteRegistry.get(app)) === null || _a === void 0 ? void 0 : _a.add(callback);
}

/**
 * A simple flag to tell if we are running on the server or not.
 */
const isServer$1 = typeof window === 'undefined';
/**
 * A registry of memoized schemas (in JSON) to their respective render function
 * and provider registry.
 */
const memo = {};
/**
 * A map of memoized keys to how many instances of that memo are currently in
 * use.
 */
const memoKeys = {};
/**
 * This object represents the current component instance during render. It is
 * critical for linking the current instance to the data required for render.
 */
let instanceKey;
/**
 * A registry of scoped data produced during runtime that is keyed by the
 * instance object. For example data from: for-loop instances and slot data.
 */
// NOTE: This is a hack to get around the fact that the TS compiler doesn't
// understand WeakMap's allowing us to use a object as a keys, see:
// https://github.com/microsoft/TypeScript/issues/52534
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const instanceScopes = new WeakMap();
/**
 * Indicates the a section of the schema is raw.
 */
const raw = '__raw__';
/**
 * Is a class prop.
 */
const isClassProp = /[a-zA-Z0-9\-][cC]lass$/;
/**
 * Returns a reference as a placeholder to a specific location on an object.
 * @param data - A reactive data object
 * @param token - A dot-syntax string representing the object path
 * @returns
 */
function getRef(token, data) {
    const value = ref(null);
    if (token === 'get') {
        const nodeRefs = {};
        value.value = get.bind(null, nodeRefs);
        return value;
    }
    const path = token.split('.');
    watchEffect(() => {
        value.value = getValue(isRef(data) ? data.value : data, path);
    });
    return value;
}
/**
 * Returns a value inside a set of data objects.
 * @param sets - An array of objects to search through
 * @param path - A array of string paths easily produced by split()
 * @returns
 */
function getValue(set, path) {
    if (Array.isArray(set)) {
        for (const subset of set) {
            const value = subset !== false && getValue(subset, path);
            if (value !== undefined)
                return value;
        }
        return undefined;
    }
    let foundValue = undefined;
    let obj = set;
    for (const i in path) {
        const key = path[i];
        if (typeof obj !== 'object' || obj === null) {
            foundValue = undefined;
            break;
        }
        const currentValue = obj[key];
        if (Number(i) === path.length - 1 && currentValue !== undefined) {
            // When the value is a function, we need to bind the `this` value
            // before providing this back to the compiler.
            foundValue =
                typeof currentValue === 'function'
                    ? currentValue.bind(obj)
                    : currentValue;
            break;
        }
        obj = currentValue;
    }
    return foundValue;
}
/**
 * Get the node from the global registry
 * @param id - A dot-syntax string where the node is located.
 */
function get(nodeRefs, id) {
    if (typeof id !== 'string')
        return warn(650);
    if (!(id in nodeRefs))
        nodeRefs[id] = ref(undefined);
    if (nodeRefs[id].value === undefined) {
        nodeRefs[id].value = null;
        const root = getNode(id);
        if (root)
            nodeRefs[id].value = root.context;
        watchRegistry(id, ({ payload: node }) => {
            nodeRefs[id].value = isNode(node) ? node.context : node;
        });
    }
    return nodeRefs[id].value;
}
/**
 *
 * @param library - A library of concrete components to use
 * @param schema -
 * @returns
 */
function parseSchema(library, schema, memoKey) {
    /**
     * Given an if/then/else schema node, pre-compile the node and return the
     * artifacts for the render function.
     * @param data - The schema context object
     * @param library - The available components
     * @param node - The node to parse
     */
    function parseCondition(library, node) {
        const condition = provider(compile(node.if), { if: true });
        const children = createElements(library, node.then);
        const alternate = node.else ? createElements(library, node.else) : null;
        return [condition, children, alternate];
    }
    /**
     * Parses a conditional if/then/else attribute statement.
     * @param data - The data object
     * @param attr - The attribute
     * @param _default - The default value
     * @returns
     */
    function parseConditionAttr(attr, _default) {
        var _a, _b;
        const condition = provider(compile(attr.if));
        let b = () => _default;
        let a = () => _default;
        if (typeof attr.then === 'object') {
            a = parseAttrs(attr.then, undefined);
        }
        else if (typeof attr.then === 'string' && ((_a = attr.then) === null || _a === void 0 ? void 0 : _a.startsWith('$'))) {
            a = provider(compile(attr.then));
        }
        else {
            a = () => attr.then;
        }
        if (has(attr, 'else')) {
            if (typeof attr.else === 'object') {
                b = parseAttrs(attr.else);
            }
            else if (typeof attr.else === 'string' && ((_b = attr.else) === null || _b === void 0 ? void 0 : _b.startsWith('$'))) {
                b = provider(compile(attr.else));
            }
            else {
                b = () => attr.else;
            }
        }
        return () => (condition() ? a() : b());
    }
    /**
     * Parse attributes for dynamic content.
     * @param attrs - Object of attributes
     * @returns
     */
    function parseAttrs(unparsedAttrs, bindExp, _default = {}) {
        const explicitAttrs = new Set(Object.keys(unparsedAttrs || {}));
        const boundAttrs = bindExp ? provider(compile(bindExp)) : () => ({});
        const setters = [
            (attrs) => {
                const bound = boundAttrs();
                for (const attr in bound) {
                    if (!explicitAttrs.has(attr)) {
                        attrs[attr] = bound[attr];
                    }
                }
            },
        ];
        if (unparsedAttrs) {
            if (isConditional(unparsedAttrs)) {
                // This is a root conditional object that must produce an object of
                // attributes.
                const condition = parseConditionAttr(unparsedAttrs, _default);
                return condition;
            }
            // Some attributes are explicitly bound, we need to parse those ones
            // using the compiler and create a dynamic "setter".
            for (let attr in unparsedAttrs) {
                const value = unparsedAttrs[attr];
                let getValue;
                const isStr = typeof value === 'string';
                if (attr.startsWith(raw)) {
                    // attributes prefixed with __raw__ should not be parsed
                    attr = attr.substring(7);
                    getValue = () => value;
                }
                else if (isStr &&
                    value.startsWith('$') &&
                    value.length > 1 &&
                    !(value.startsWith('$reset') && isClassProp.test(attr))) {
                    // Most attribute values starting with $ should be compiled
                    // -class attributes starting with `$reset` should not be compiled
                    getValue = provider(compile(value));
                }
                else if (typeof value === 'object' && isConditional(value)) {
                    // Conditional attrs require further processing
                    getValue = parseConditionAttr(value, undefined);
                }
                else if (typeof value === 'object' && isPojo(value)) {
                    // Sub-parse pojos
                    getValue = parseAttrs(value);
                }
                else {
                    // In all other cases, the value is static
                    getValue = () => value;
                }
                setters.push((attrs) => {
                    attrs[attr] = getValue();
                });
            }
        }
        return () => {
            const attrs = Array.isArray(unparsedAttrs) ? [] : {};
            setters.forEach((setter) => setter(attrs));
            return attrs;
        };
    }
    /**
     * Given a single schema node, parse it and extract the value.
     * @param data - A state object provided to each node
     * @param node - The schema node being parsed
     * @returns
     */
    function parseNode(library, _node) {
        let element = null;
        let attrs = () => null;
        let condition = false;
        let children = null;
        let alternate = null;
        let iterator = null;
        let resolve = false;
        const node = sugar(_node);
        if (isDOM(node)) {
            // This is an actual HTML DOM element
            element = node.$el;
            attrs =
                node.$el !== 'text' ? parseAttrs(node.attrs, node.bind) : () => null;
        }
        else if (isComponent$1(node)) {
            // This is a Vue Component
            if (typeof node.$cmp === 'string') {
                if (has(library, node.$cmp)) {
                    element = library[node.$cmp];
                }
                else {
                    element = node.$cmp;
                    resolve = true;
                }
            }
            else {
                // in this case it must be an actual component
                element = node.$cmp;
            }
            attrs = parseAttrs(node.props, node.bind);
        }
        else if (isConditional(node)) {
            [condition, children, alternate] = parseCondition(library, node);
        }
        // This is the same as a "v-if" statement — not an if/else statement
        if (!isConditional(node) && 'if' in node) {
            condition = provider(compile(node.if));
        }
        else if (!isConditional(node) && element === null) {
            // In this odd case our element is actually a partial and
            // we only want to render the children.
            condition = () => true;
        }
        // Compile children down to a function
        if ('children' in node && node.children) {
            if (typeof node.children === 'string') {
                // We are dealing with a raw string value
                if (node.children.startsWith('$slots.')) {
                    // this is a lone text node, turn it into a slot
                    element = element === 'text' ? 'slot' : element;
                    children = provider(compile(node.children));
                }
                else if (node.children.startsWith('$') && node.children.length > 1) {
                    const value = provider(compile(node.children));
                    children = () => String(value());
                }
                else {
                    children = () => String(node.children);
                }
            }
            else if (Array.isArray(node.children)) {
                // We are dealing with node sub-children
                children = createElements(library, node.children);
            }
            else {
                // This is a conditional if/else clause
                const [childCondition, c, a] = parseCondition(library, node.children);
                children = (iterationData) => childCondition && childCondition()
                    ? c && c(iterationData)
                    : a && a(iterationData);
            }
        }
        if (isComponent$1(node)) {
            if (children) {
                // Children of components need to be provided as an object of slots
                // so we provide an object with the default slot provided as children.
                // We also create a new scope for this default slot, and then on each
                // render pass the scoped slot props to the scope.
                const produceChildren = children;
                children = (iterationData) => {
                    return {
                        default(slotData, key) {
                            var _a, _b, _c, _d;
                            // We need to switch the current instance key back to the one that
                            // originally called this component's render function.
                            const currentKey = instanceKey;
                            if (key)
                                instanceKey = key;
                            if (slotData)
                                (_a = instanceScopes.get(instanceKey)) === null || _a === void 0 ? void 0 : _a.unshift(slotData);
                            if (iterationData)
                                (_b = instanceScopes.get(instanceKey)) === null || _b === void 0 ? void 0 : _b.unshift(iterationData);
                            const c = produceChildren(iterationData);
                            // Ensure our instance key never changed during runtime
                            if (slotData)
                                (_c = instanceScopes.get(instanceKey)) === null || _c === void 0 ? void 0 : _c.shift();
                            if (iterationData)
                                (_d = instanceScopes.get(instanceKey)) === null || _d === void 0 ? void 0 : _d.shift();
                            instanceKey = currentKey;
                            return c;
                        },
                    };
                };
                children.slot = true;
            }
            else {
                // If we dont have any children, we still need to provide an object
                // instead of an empty array (which raises a warning in vue)
                children = () => ({});
            }
        }
        // Compile the for loop down
        if ('for' in node && node.for) {
            const values = node.for.length === 3 ? node.for[2] : node.for[1];
            const getValues = typeof values === 'string' && values.startsWith('$')
                ? provider(compile(values))
                : () => values;
            iterator = [
                getValues,
                node.for[0],
                node.for.length === 3 ? String(node.for[1]) : null,
            ];
        }
        return [condition, element, attrs, children, alternate, iterator, resolve];
    }
    /**
     * Given a particular function that produces children, ensure that the second
     * argument of all these slots is the original instance key being used to
     * render the slots.
     * @param children - The children() function that will produce slots
     */
    function createSlots(children, iterationData) {
        const slots = children(iterationData);
        const currentKey = instanceKey;
        return Object.keys(slots).reduce((allSlots, slotName) => {
            const slotFn = slots && slots[slotName];
            allSlots[slotName] = (data) => {
                return (slotFn && slotFn(data, currentKey)) || null;
            };
            return allSlots;
        }, {});
    }
    /**
     * Creates an element
     * @param data - The context data available to the node
     * @param node - The schema node to render
     * @returns
     */
    function createElement(library, node) {
        // Parses the schema node into pertinent parts
        const [condition, element, attrs, children, alternate, iterator, resolve] = parseNode(library, node);
        // This is a sub-render function (called within a render function). It must
        // only use pre-compiled features, and be organized in the most efficient
        // manner possible.
        let createNodes = ((iterationData) => {
            if (condition && element === null && children) {
                // Handle conditional if/then statements
                return condition()
                    ? children(iterationData)
                    : alternate && alternate(iterationData);
            }
            if (element && (!condition || condition())) {
                // handle text nodes
                if (element === 'text' && children) {
                    return createTextVNode(String(children()));
                }
                // Handle lone slots
                if (element === 'slot' && children)
                    return children(iterationData);
                // Handle resolving components
                const el = resolve ? resolveComponent(element) : element;
                // If we are rendering slots as children, ensure their instanceKey is properly added
                const slots = (children === null || children === void 0 ? void 0 : children.slot)
                    ? createSlots(children, iterationData)
                    : null;
                // Handle dom elements and components
                return h(el, attrs(), (slots || (children ? children(iterationData) : [])));
            }
            return typeof alternate === 'function'
                ? alternate(iterationData)
                : alternate;
        });
        if (iterator) {
            const repeatedNode = createNodes;
            const [getValues, valueName, keyName] = iterator;
            createNodes = (() => {
                const _v = getValues();
                const values = Number.isFinite(_v)
                    ? Array(Number(_v))
                        .fill(0)
                        .map((_, i) => i)
                    : _v;
                const fragment = [];
                if (typeof values !== 'object')
                    return null;
                const instanceScope = instanceScopes.get(instanceKey) || [];
                const isArray = Array.isArray(values);
                for (const key in values) {
                    if (isArray && key in Array.prototype)
                        continue; // Fix #299
                    const iterationData = Object.defineProperty({
                        ...instanceScope.reduce((previousIterationData, scopedData) => {
                            if (previousIterationData.__idata) {
                                return { ...previousIterationData, ...scopedData };
                            }
                            return scopedData;
                        }, {}),
                        [valueName]: values[key],
                        ...(keyName !== null
                            ? { [keyName]: isArray ? Number(key) : key }
                            : {}),
                    }, '__idata', { enumerable: false, value: true });
                    instanceScope.unshift(iterationData);
                    fragment.push(repeatedNode.bind(null, iterationData)());
                    instanceScope.shift();
                }
                return fragment;
            });
        }
        return createNodes;
    }
    /**
     * Given a schema, parse it and return the resulting renderable nodes.
     * @param data - The schema context object
     * @param library - The available components
     * @param node - The node to parse
     * @returns
     */
    function createElements(library, schema) {
        if (Array.isArray(schema)) {
            const els = schema.map(createElement.bind(null, library));
            return (iterationData) => els.map((element) => element(iterationData));
        }
        // Single node to render
        const element = createElement(library, schema);
        return (iterationData) => element(iterationData);
    }
    /**
     * Data providers produced as a result of the compiler.
     */
    const providers = [];
    /**
     * Append the requisite compiler provider and return the compiled function.
     * @param compiled - A compiled function
     * @returns
     */
    function provider(compiled, hints = {}) {
        const compiledFns = new WeakMap();
        providers.push((callback, key) => {
            compiledFns.set(key, compiled.provide((tokens) => callback(tokens, hints)));
        });
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return () => compiledFns.get(instanceKey)();
    }
    /**
     * Creates a new instance of a given schema — this either comes from a
     * memoized copy of the parsed schema or a freshly parsed version. An object
     * instance key, and dataProvider functions are passed in.
     * @param providerCallback - A function that is called for each required provider
     * @param key - a object representing the current instance
     */
    function createInstance(providerCallback, key) {
        var _a;
        memoKey !== null && memoKey !== void 0 ? memoKey : (memoKey = toMemoKey(schema));
        const [render, compiledProviders] = has(memo, memoKey)
            ? memo[memoKey]
            : [createElements(library, schema), providers];
        if (!isServer$1) {
            (_a = memoKeys[memoKey]) !== null && _a !== void 0 ? _a : (memoKeys[memoKey] = 0);
            memoKeys[memoKey]++;
            memo[memoKey] = [render, compiledProviders];
        }
        compiledProviders.forEach((compiledProvider) => {
            compiledProvider(providerCallback, key);
        });
        return () => {
            // Set the instance key for this pass of rendering.
            instanceKey = key;
            return render();
        };
    }
    return createInstance;
}
/**
 * Checks the current runtime scope for data.
 * @param token - The token to lookup in the current scope
 * @param defaultValue - The default ref value to use if no scope is found.
 */
function useScope(token, defaultValue) {
    const scopedData = instanceScopes.get(instanceKey) || [];
    let scopedValue = undefined;
    if (scopedData.length) {
        scopedValue = getValue(scopedData, token.split('.'));
    }
    return scopedValue === undefined ? defaultValue : scopedValue;
}
/**
 * Get the current scoped data and flatten it.
 */
function slotData(data, key) {
    return new Proxy(data, {
        get(...args) {
            let data = undefined;
            const property = args[1];
            if (typeof property === 'string') {
                const prevKey = instanceKey;
                instanceKey = key;
                data = useScope(property, undefined);
                instanceKey = prevKey;
            }
            return data !== undefined ? data : Reflect.get(...args);
        },
    });
}
/**
 * Provides data to a parsed schema.
 * @param provider - The SchemaProvider (output of calling parseSchema)
 * @param data - Data to fetch values from
 * @returns
 */
function createRenderFn(instanceCreator, data, instanceKey) {
    return instanceCreator((requirements, hints = {}) => {
        return requirements.reduce((tokens, token) => {
            if (token.startsWith('slots.')) {
                const slot = token.substring(6);
                const hasSlot = () => data.slots &&
                    has(data.slots, slot) &&
                    typeof data.slots[slot] === 'function';
                if (hints.if) {
                    // If statement — dont render the slot, check if it exists
                    tokens[token] = hasSlot;
                }
                else if (data.slots) {
                    // Render the slot with current scope data
                    const scopedData = slotData(data, instanceKey);
                    tokens[token] = () => hasSlot() ? data.slots[slot](scopedData) : null;
                }
            }
            else {
                const value = getRef(token, data);
                tokens[token] = () => useScope(token, value.value);
            }
            return tokens;
        }, {});
    }, instanceKey);
}
/**
 * Removes the schema from the memo and cleans up the instance scope.
 * @param schema - The schema to remove from memo.
 * @param instanceKey - The instance key to remove.
 */
function clean(schema, memoKey, instanceKey) {
    memoKey !== null && memoKey !== void 0 ? memoKey : (memoKey = toMemoKey(schema));
    memoKeys[memoKey]--;
    if (memoKeys[memoKey] === 0) {
        delete memoKeys[memoKey];
        const [, providers] = memo[memoKey];
        delete memo[memoKey];
        providers.length = 0;
    }
    instanceScopes.delete(instanceKey);
}
/**
 * Convert a schema to a memo key.
 * @param schema - A schema to convert to a memo key
 */
function toMemoKey(schema) {
    return JSON.stringify(schema, (_, value) => {
        // Technically there shouldn’t be any functions in here, but just in case
        // we want to sniff them out and convert them to strings
        // See: https://github.com/formkit/formkit/issues/933
        if (typeof value === 'function') {
            return value.toString();
        }
        return value;
    });
}
/**
 * The FormKitSchema vue component:
 *
 * @public
 */
const FormKitSchema = /* #__PURE__ */ defineComponent({
    name: 'FormKitSchema',
    props: {
        schema: {
            type: [Array, Object],
            required: true,
        },
        data: {
            type: Object,
            default: () => ({}),
        },
        library: {
            type: Object,
            default: () => ({}),
        },
        memoKey: {
            type: String,
            required: false,
        },
    },
    setup(props, context) {
        var _a;
        const instance = getCurrentInstance();
        let instanceKey = {};
        instanceScopes.set(instanceKey, []);
        const library = { FormKit: markRaw(formkitComponent), ...props.library };
        let provider = parseSchema(library, props.schema, props.memoKey);
        let render;
        let data;
        // // Re-parse the schema if it changes:
        if (!isServer$1) {
            watch(() => props.schema, (newSchema, oldSchema) => {
                var _a;
                const oldKey = instanceKey;
                instanceKey = {};
                instanceScopes.set(instanceKey, []);
                provider = parseSchema(library, props.schema, props.memoKey);
                render = createRenderFn(provider, data, instanceKey);
                if (newSchema === oldSchema) {
                    ((_a = instance === null || instance === void 0 ? void 0 : instance.proxy) === null || _a === void 0 ? void 0 : _a.$forceUpdate)();
                }
                clean(props.schema, props.memoKey, oldKey);
            }, { deep: true });
        }
        // // Watch the data object explicitly
        watchEffect(() => {
            var _a;
            data = Object.assign(reactive((_a = props.data) !== null && _a !== void 0 ? _a : {}), {
                slots: context.slots,
            });
            context.slots;
            render = createRenderFn(provider, data, instanceKey);
        });
        /**
         * Perform cleanup operations when the component is unmounted. This should
         * remove any memory allocations that were made during the render process.
         */
        function cleanUp() {
            // Perform cleanup operations
            clean(props.schema, props.memoKey, instanceKey);
            /* eslint-disable @typescript-eslint/no-non-null-assertion */
            if (data.node)
                data.node.destroy();
            data.slots = null;
            data = null;
            render = null;
            /* eslint-enable @typescript-eslint/no-non-null-assertion */
        }
        // For browser rendering:
        onUnmounted(cleanUp);
        // For SSR rendering:
        onSSRComplete((_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.appContext.app, cleanUp);
        return () => (render ? render() : null);
    },
});

/**
 * Flag to determine if we are running on the server.
 */
const isServer = typeof window === 'undefined';
/**
 * The symbol that represents the formkit parent injection value.
 *
 * @public
 */
const parentSymbol = Symbol('FormKitParent');
/**
 * This variable is set to the node that is currently having its schema created.
 *
 * @internal
 */
let currentSchemaNode = null;
/**
 * Returns the node that is currently having its schema created.
 *
 * @public
 */
const getCurrentSchemaNode = () => currentSchemaNode;
/**
 * The actual runtime setup function for the FormKit component.
 *
 * @param props - The props passed to the component.
 * @param context - The context passed to the component.
 */
function FormKit(props, context) {
    const node = useInput(props, context);
    if (!node.props.definition)
        error(600, node);
    if (node.props.definition.component) {
        return () => {
            var _a;
            return h((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.component, {
                context: node.context,
            }, { ...context.slots });
        };
    }
    const schema = ref([]);
    let memoKey = node.props.definition.schemaMemoKey;
    const generateSchema = () => {
        var _a, _b;
        const schemaDefinition = (_b = (_a = node.props) === null || _a === void 0 ? void 0 : _a.definition) === null || _b === void 0 ? void 0 : _b.schema;
        if (!schemaDefinition)
            error(601, node);
        if (typeof schemaDefinition === 'function') {
            currentSchemaNode = node;
            schema.value = schemaDefinition({ ...props.sectionsSchema });
            currentSchemaNode = null;
            if ((memoKey && props.sectionsSchema) ||
                ('memoKey' in schemaDefinition &&
                    typeof schemaDefinition.memoKey === 'string')) {
                memoKey =
                    (memoKey !== null && memoKey !== void 0 ? memoKey : schemaDefinition === null || schemaDefinition === void 0 ? void 0 : schemaDefinition.memoKey) +
                        JSON.stringify(props.sectionsSchema);
            }
        }
        else {
            schema.value = schemaDefinition;
        }
    };
    generateSchema();
    // // If someone emits the schema event, we re-generate the schema
    if (!isServer) {
        node.on('schema', () => {
            memoKey += '♻️';
            generateSchema();
        });
    }
    context.emit('node', node);
    const definitionLibrary = node.props.definition.library;
    const library = {
        FormKit: markRaw(formkitComponent),
        ...definitionLibrary,
    };
    // // Expose the FormKitNode to template refs.
    context.expose({ node });
    return () => h(FormKitSchema, { schema: schema.value, data: node.context, library, memoKey }, { ...context.slots });
}
/**
 * The root FormKit component. Use it to craft all inputs and structure of your
 * forms. For example:
 *
 * ```vue
 * <FormKit
 *  type="text"
 *  label="Name"
 *  help="Please enter your name"
 *  validation="required|length:2"
 * />
 * ```
 *
 * @public
 */
const formkitComponent = /* #__PURE__ */ defineComponent(FormKit, {
    props: runtimeProps,
    inheritAttrs: false,
});

/**
 * The symbol that represents the formkit’s root element injection value.
 *
 * @public
 */
const rootSymbol = Symbol();
/**
 * The FormKitRoot wrapper component used to provide context to FormKit about
 * whether a FormKit input is booting in a Document or ShadowRoot. This is
 * generally only necessary when booting FormKit nodes in contexts that do not
 * have a document. For example, if running code like this:
 *
 * ```ts
 * document.getElementById(node.props.id)
 * ```
 *
 * does not work because the `document` is not available or is not in the same
 * scope, you can place a `<FormKitRoot>` component somewhere near the root of
 * of your shadowRoot and it will inform any FormKitNode child (at any depth)
 * that it is running in a shadow root. The "root" (`Document` or `ShadowRoot`)
 * will be made available to all child nodes at `node.context._root`
 *
 * @public
 */
const FormKitRoot = /* #__PURE__ */ defineComponent((_p, context) => {
    const boundary = ref(null);
    const showBody = ref(false);
    const shadowRoot = ref(undefined);
    const stopWatch = watch(boundary, (el) => {
        let parent = el;
        let root = null;
        while ((parent = parent === null || parent === void 0 ? void 0 : parent.parentNode)) {
            root = parent;
            if (root instanceof ShadowRoot || root instanceof Document) {
                foundRoot(root);
                break;
            }
        }
        stopWatch();
        showBody.value = true;
    });
    provide(rootSymbol, shadowRoot);
    function foundRoot(root) {
        shadowRoot.value = root;
    }
    return () => showBody.value && context.slots.default
        ? context.slots.default()
        : h('template', { ref: boundary });
});

/**
 * The Create a new instance of the FormKit plugin for Vue.
 *
 * @param app - A Vue application
 * @param config - FormKit Vue plugin configuration options
 *
 * @internal
 */
function createPlugin(app, options) {
    app
        .component(options.alias || 'FormKit', formkitComponent)
        .component(options.schemaAlias || 'FormKitSchema', FormKitSchema);
    return {
        get: getNode,
        setLocale: (locale) => {
            var _a;
            if ((_a = options.config) === null || _a === void 0 ? void 0 : _a.rootConfig) {
                options.config.rootConfig.locale = locale;
            }
        },
        clearErrors,
        setErrors,
        submit: submitForm,
        reset,
    };
}
/**
 * The symbol key for accessing the FormKit node options.
 *
 * @public
 */
const optionsSymbol = Symbol.for('FormKitOptions');
/**
 * The symbol key for accessing FormKit root configuration.
 *
 * @public
 */
const configSymbol = Symbol.for('FormKitConfig');
/**
 * Create the FormKit plugin.
 *
 * @public
 */
const plugin = {
    install(app, _options) {
        /**
         * Extend the default configuration options.
         */
        const options = Object.assign({
            alias: 'FormKit',
            schemaAlias: 'FormKitSchema',
        }, typeof _options === 'function' ? _options() : _options);
        /**
         * The root configuration options.
         */
        const rootConfig = createConfig(options.config || {});
        /**
         * We dont want to explicitly provide any "config" options, only a root
         * config option — so here we override the existing config options.
         */
        options.config = { rootConfig };
        /**
         * Register the global $formkit plugin property.
         */
        app.config.globalProperties.$formkit = createPlugin(app, options);
        /**
         * Provide the config to the application for injection.
         */
        app.provide(optionsSymbol, options);
        /**
         * Provide the root config to the application.
         */
        app.provide(configSymbol, rootConfig);
        /**
         * Register the FormKit component globally.
         */
        if (typeof window !== 'undefined') {
            globalThis.__FORMKIT_CONFIGS__ = (globalThis.__FORMKIT_CONFIGS__ || []).concat([rootConfig]);
        }
    },
};

const isBrowser = typeof window !== 'undefined';
/**
 * Props that are extracted from the attrs object.
 * TODO: Currently local, this should probably exported to a inputs or another
 * package.
 */
const pseudoProps = [
    'help',
    'label',
    'ignore',
    'disabled',
    'preserve',
    /^preserve(-e|E)rrors/,
    /^[a-z]+(?:-visibility|Visibility|-behavior|Behavior)$/,
    /^[a-zA-Z-]+(?:-class|Class)$/,
    'prefixIcon',
    'suffixIcon',
    /^[a-zA-Z-]+(?:-icon|Icon)$/,
];
/**
 * Given some props, map those props to individualized props internally.
 * @param node - A formkit node
 * @param props - Some props that may include a classes object
 */
function classesToNodeProps(node, props) {
    if (props.classes) {
        Object.keys(props.classes).forEach((key) => {
            if (typeof key === 'string') {
                node.props[`_${key}Class`] = props.classes[key];
                // We need to ensure Vue is aware that we want to actually observe the
                // child values too, so we touch them here.
                if (isObject(props.classes[key]) && key === 'inner')
                    Object.values(props.classes[key]);
            }
        });
    }
}
/**
 * Extracts known FormKit listeners.
 * @param props - Extract known FormKit listeners.
 * @returns
 */
function onlyListeners(props) {
    if (!props)
        return {};
    const knownListeners = ['Submit', 'SubmitRaw', 'SubmitInvalid'].reduce((listeners, listener) => {
        const name = `on${listener}`;
        if (name in props) {
            if (typeof props[name] === 'function') {
                listeners[name] = props[name];
            }
        }
        return listeners;
    }, {});
    return knownListeners;
}
/**
 * A composable for creating a new FormKit node.
 *
 * @param type - The type of node (input, group, list)
 * @param attrs - The FormKit "props" — which is really the attrs list.
 *
 * @returns {@link @formkit/core#FormKitNode | FormKitNode}
 *
 * @public
 */
function useInput(props, context, options = {}) {
    var _a;
    /**
     * The configuration options, these are provided by either the plugin or by
     * explicit props.
     */
    const config = Object.assign({}, inject(optionsSymbol) || {}, options);
    /**
     * The root element — generally this is either a Document or ShadowRoot.
     */
    const __root = inject(rootSymbol, ref(isBrowser ? document : undefined));
    /**
     * The current instance.
     */
    const instance = getCurrentInstance();
    /**
     * Extracts the listeners.
     */
    const listeners = onlyListeners(instance === null || instance === void 0 ? void 0 : instance.vnode.props);
    /**
     * Determines if the prop is v-modeled. Credit to:
     * {@link https://github.com/LinusBorg | Thorsten Lünborg}
     * for coming up with this solution.
     */
    const isVModeled = ['modelValue', 'model-value'].some((prop) => { var _a; return prop in ((_a = instance === null || instance === void 0 ? void 0 : instance.vnode.props) !== null && _a !== void 0 ? _a : {}); });
    // Track if the input has mounted or not.
    let isMounted = false;
    onMounted(() => {
        isMounted = true;
    });
    /**
     * Determines if the object being passed as a v-model is reactive.
     */
    // const isReactiveVModel = isVModeled && isReactive(props.modelValue)
    /**
     * Define the initial component
     */
    const value = props.modelValue !== undefined
        ? props.modelValue
        : cloneAny(context.attrs.value);
    /**
     * Creates the node's initial props from the context, props, and definition
     * @returns
     */
    function createInitialProps() {
        var _a;
        const initialProps = {
            ...nodeProps(props),
            ...listeners,
            type: (_a = props.type) !== null && _a !== void 0 ? _a : 'text',
            __root: __root.value,
            __slots: context.slots,
        };
        const attrs = except(nodeProps(context.attrs), pseudoProps);
        if (!attrs.key)
            attrs.key = token();
        initialProps.attrs = attrs;
        const propValues = only(nodeProps(context.attrs), pseudoProps);
        for (const propName in propValues) {
            initialProps[camel(propName)] = propValues[propName];
        }
        const classesProps = { props: {} };
        classesToNodeProps(classesProps, props);
        Object.assign(initialProps, classesProps.props);
        if (typeof initialProps.type !== 'string') {
            initialProps.definition = initialProps.type;
            delete initialProps.type;
        }
        return initialProps;
    }
    /**
     * Create the FormKitNode.
     */
    const initialProps = createInitialProps();
    /**
     * The parent node.
     */
    const parent = initialProps.ignore
        ? null
        : props.parent || inject(parentSymbol, null);
    const node = createNode(extend(config || {}, {
        name: props.name || undefined,
        value,
        parent,
        plugins: (config.plugins || []).concat((_a = props.plugins) !== null && _a !== void 0 ? _a : []),
        config: props.config || {},
        props: initialProps,
        index: props.index,
        sync: !!undefine(context.attrs.sync || context.attrs.dynamic),
    }, false, true));
    /**
     * If no definition has been assigned at this point — we're out!
     */
    if (!node.props.definition)
        error(600, node);
    /**
     * All props that are bound "late" (after node creation) — are added to a set
     * which is used to watch the context.attrs object.
     */
    const lateBoundProps = ref(new Set(node.props.definition.props || []));
    /**
     * Any additional props added at a "later" time should also be part of the
     * late bound props.
     */
    node.on('added-props', ({ payload: lateProps }) => {
        if (Array.isArray(lateProps))
            lateProps.forEach((newProp) => lateBoundProps.value.add(newProp));
    });
    /**
     * These prop names must be assigned.
     */
    const pseudoPropNames = computed(() => pseudoProps.concat([...lateBoundProps.value]).reduce((names, prop) => {
        if (typeof prop === 'string') {
            names.push(camel(prop));
            names.push(kebab(prop));
        }
        else {
            names.push(prop);
        }
        return names;
    }, []));
    /* Splits Classes object into discrete props for each key */
    watchEffect(() => classesToNodeProps(node, props));
    /**
     * The props object already has properties even if they start as "undefined"
     * so we can loop over them and individual watchEffect to prevent responding
     * inappropriately.
     */
    const passThrough = nodeProps(props);
    for (const prop in passThrough) {
        watch(() => props[prop], () => {
            if (props[prop] !== undefined) {
                node.props[prop] = props[prop];
            }
        });
    }
    // Ensure the root always stays up to date.
    watchEffect(() => {
        node.props.__root = __root.value;
    });
    /**
     * Watch "pseudoProp" attributes explicitly.
     */
    const attributeWatchers = new Set();
    const possibleProps = nodeProps(context.attrs);
    watchEffect(() => {
        watchAttributes(only(possibleProps, pseudoPropNames.value));
    });
    /**
     * Defines attributes that should be used as props.
     * @param attrProps - Attributes that should be used as props instead
     */
    function watchAttributes(attrProps) {
        attributeWatchers.forEach((stop) => {
            stop();
            attributeWatchers.delete(stop);
        });
        for (const prop in attrProps) {
            const camelName = camel(prop);
            attributeWatchers.add(watch(() => context.attrs[prop], () => {
                node.props[camelName] = context.attrs[prop];
            }));
        }
    }
    /**
     * Watch and dynamically set attribute values, those values that are not
     * props and are not pseudoProps
     */
    watchEffect(() => {
        const attrs = except(nodeProps(context.attrs), pseudoPropNames.value);
        // An explicit exception to ensure naked "multiple" attributes appear on the
        // outer wrapper as data-multiple="true"
        if ('multiple' in attrs)
            attrs.multiple = undefine(attrs.multiple);
        if (typeof attrs.onBlur === 'function') {
            attrs.onBlur = oncePerTick(attrs.onBlur);
        }
        node.props.attrs = Object.assign({}, node.props.attrs || {}, attrs);
    });
    /**
     * Add any/all "prop" errors to the store.
     */
    watchEffect(() => {
        var _a;
        const messages = ((_a = props.errors) !== null && _a !== void 0 ? _a : []).map((error) => createMessage({
            key: slugify(error),
            type: 'error',
            value: error,
            meta: { source: 'prop' },
        }));
        node.store.apply(messages, (message) => message.type === 'error' && message.meta.source === 'prop');
    });
    /**
     * Add input errors.
     */
    if (node.type !== 'input') {
        const sourceKey = `${node.name}-prop`;
        watchEffect(() => {
            var _a;
            const inputErrors = (_a = props.inputErrors) !== null && _a !== void 0 ? _a : {};
            const keys = Object.keys(inputErrors);
            if (!keys.length)
                node.clearErrors(true, sourceKey);
            const messages = keys.reduce((messages, key) => {
                let value = inputErrors[key];
                if (typeof value === 'string')
                    value = [value];
                if (Array.isArray(value)) {
                    messages[key] = value.map((error) => createMessage({
                        key: error,
                        type: 'error',
                        value: error,
                        meta: { source: sourceKey },
                    }));
                }
                return messages;
            }, {});
            node.store.apply(messages, (message) => message.type === 'error' && message.meta.source === sourceKey);
        });
    }
    /**
     * Watch the config prop for any changes.
     */
    watchEffect(() => Object.assign(node.config, props.config));
    /**
     * Produce another parent object.
     */
    if (node.type !== 'input') {
        provide(parentSymbol, node);
    }
    // let inputTimeout: number | undefined
    let clonedValueBeforeVmodel = undefined;
    /**
     * Explicitly watch the input value, and emit changes (lazy)
     */
    node.on('modelUpdated', () => {
        var _a, _b;
        // Emit the values after commit
        context.emit('inputRaw', (_a = node.context) === null || _a === void 0 ? void 0 : _a.value, node);
        if (isMounted) {
            context.emit('input', (_b = node.context) === null || _b === void 0 ? void 0 : _b.value, node);
        }
        if (isVModeled && node.context) {
            clonedValueBeforeVmodel = cloneAny(node.value);
            context.emit('update:modelValue', shallowClone(node.value));
        }
    });
    /**
     * Enabled support for v-model, using this for groups/lists is not recommended
     */
    if (isVModeled) {
        watch(toRef(props, 'modelValue'), (value) => {
            if (!eq(clonedValueBeforeVmodel, value)) {
                node.input(value, false);
            }
        }, { deep: true });
        /**
         * On initialization, if the node’s value was updated (like in a plugin
         * hook) then we should emit a `modelUpdated` event.
         */
        if (node.value !== value) {
            node.emit('modelUpdated');
        }
    }
    /**
     * When this input shuts down, we need to "delete" the node too.
     */
    onBeforeUnmount(() => node.destroy());
    return node;
}

let totalCreated = 1;
/**
 * Determine if the given object is a vue component.
 *
 * @param obj - Object or function
 * @returns
 * @public
 */
function isComponent(obj) {
    return ((typeof obj === 'function' && obj.length === 2) ||
        (typeof obj === 'object' &&
            !Array.isArray(obj) &&
            !('$el' in obj) &&
            !('$cmp' in obj) &&
            !('if' in obj)));
}
/**
 * Creates a new input from schema or a Vue component with the "standard"
 * FormKit features in place such as labels, help text, validation messages, and
 * class support.
 *
 * @param schemaOrComponent - The actual schema of the input or the component.
 * @param definitionOptions - Any options in the FormKitTypeDefinition you want
 * to define.
 *
 * @returns {@link @formkit/core#FormKitTypeDefinition | FormKitTypeDefinition}
 *
 * @public
 */
function createInput(schemaOrComponent, definitionOptions = {}) {
    const definition = {
        type: 'input',
        ...definitionOptions,
    };
    let schema;
    if (isComponent(schemaOrComponent)) {
        const cmpName = `SchemaComponent${totalCreated++}`;
        schema = createSection('input', () => ({
            $cmp: cmpName,
            props: {
                context: '$node.context',
            },
        }));
        definition.library = { [cmpName]: markRaw(schemaOrComponent) };
    }
    else if (typeof schemaOrComponent === 'function') {
        schema = schemaOrComponent;
    }
    else {
        schema = createSection('input', () => cloneAny(schemaOrComponent));
    }
    // Use the default wrapping schema
    definition.schema = useSchema(schema || 'Schema undefined');
    if (!definition.schemaMemoKey) {
        definition.schemaMemoKey = `${Math.random()}`;
    }
    return definition;
}

function defineFormKitConfig(config) {
    return () => (typeof config === 'function' ? config() : config);
}

let inputList = {};
const schemas = {};
const classes = {
    container: `
    formkit-kitchen-sink 
    p-8
  `,
    tabs: `
    formkit-tabs 
    mt-4 
    mr-[min(350px,25vw)]
  `,
    tab: `
    formkit-kitchen-sink-tab
    inline-block
    mb-4
    -mr-px
    cursor-pointer
    px-4
    py-2
    border
    border-neutral-200
    text-neutral-800
    data-[active]:bg-neutral-800
    data-[active]:border-neutral-800
    data-[active]:text-neutral-50
    hover:bg-neutral-100
    hover:text-neutral-900
    dark:border-neutral-700
    dark:text-neutral-50
    dark:data-[active]:bg-neutral-100
    dark:data-[active]:border-neutral-100
    dark:data-[active]:text-neutral-800
    dark:hover:bg-neutral-800
    dark:hover:text-neutral-50
  `,
    filterContainer: `
    formkit-filter-container
    grid
    grid-cols-[repeat(auto-fit,300px)]
    mr-[min(350px,25vw)]
    -mt-4
    mb-8
    px-4
    pt-8
    pb-4
    border
    relative
    -translate-y-px
    max-w-[1000px]
    border-neutral-200
    dark:border-neutral-700
  `,
    filterGroup: `
    formkit-filter-group
    mr-8
    mb-8
    [&_legend]:text-lg
    [&_ul]:columns-2
    [&_ul>li:first-child]:[column-span:all]
    [&_ul>li:first-child]:mt-2
    [&_ul>li:first-child]:mb-2
    [&_ul>li:first-child]:pb-2
    [&_ul>li:first-child]:border-b
    [&_ul>li:first-child]:border-neutral-200
    dark:[&_ul>li:first-child]:border-neutral-700
  `,
    formContainer: `
    formkit-form-container
    w-full
    bg-white
    rounded
    border
    border-neutral-100
    shadow-lg
    max-w-[800px]
    p-[min(5vw,5rem)]
    dark:bg-neutral-900
    dark:border-neutral-800
    dark:shadow-3xl
    [&_form>h1]:text-2xl
    [&_form>h1]:mb-4
    [&_form>h1]:font-bold
    [&_form>h1+p]:text-base
    [&_form>h1+p]:mb-4
    [&_form>h1+p]:-mt-2
    [&_form_.double]:flex
    [&_form_.double>*]:w-1/2
    [&_form_.double>*:first-child]:mr-2
    [&_form_.triple]:flex
    [&_form_.triple>*]:w-1/3
    [&_form_.triple>*:first-child]:mr-2
    [&_form_.triple>*:last-child]:ml-2
  `,
    inputs: `formkit-inputs`,
    specimen: `
    formkit-specimen 
    flex 
    flex-col 
    p-2 
    max-w-[75vw]
  `,
    inputSection: `
    group/section
    formkit-input-section 
    mr-[min(325px,25vw)]
  `,
    specimenGroup: `
    formkit-specimen-group
    grid
    mb-16
    grid-cols-[repeat(auto-fit,400px)]
    group-data-[type="transferlist"]/section:grid-cols-[repeat(auto-fit,650px)]
    group-data-[type="multi-step"]/section:grid-cols-[repeat(auto-fit,550px)]
  `,
    inputType: `
    formkit-input-type
    block
    font-bold
    text-neutral-900
    border-b
    border-neutral-100
    text-3xl
    mb-8
    pb-2
    capitalize
    dark:border-neutral-800 
    dark:text-neutral-50
  `,
};
/**
 * Fetches the list of inputs from the remote schema repository
 */
async function fetchInputList() {
    const response = await fetch('https://raw.githubusercontent.com/formkit/input-schemas/master/index.json');
    const json = await response.json();
    return json;
}
/**
 * Fetches the list of inputs from the remote schema repository
 */
async function fetchInputSchema(input) {
    try {
        const response = await fetch(`https://raw.githubusercontent.com/formkit/input-schemas/master/schemas/${input}.json`);
        const json = await response.json();
        return json;
    }
    catch (error) {
        console.error(error);
    }
}
/**
 * Renders FormKit components fetched from a remote schema repository.
 * This is a kitchen sink component that is used for testing purposes.
 * It shows inputs in various states and configurations.
 *
 * @public
 */
const FormKitKitchenSink = /* #__PURE__ */ defineComponent({
    name: 'FormKitKitchenSink',
    props: {
        schemas: {
            type: Array,
            required: false,
        },
        pro: {
            type: Boolean,
            default: true,
        },
        addons: {
            type: Boolean,
            default: true,
        },
        forms: {
            type: Boolean,
            default: true,
        },
        navigation: {
            type: Boolean,
            default: true,
        },
    },
    async setup(props) {
        onMounted(() => {
            const filterNode = getNode('filter-checkboxes');
            data.filters = computed(() => {
                if (!(filterNode === null || filterNode === void 0 ? void 0 : filterNode.context))
                    return [];
                const filters = filterNode.context.value;
                const filterValues = [];
                Object.keys(filters).forEach((key) => {
                    filterValues.push(...filters[key]);
                });
                return filterValues;
            });
        });
        inputList = Object.keys(inputList).length
            ? inputList
            : await fetchInputList();
        const promises = [];
        const activeTab = ref('');
        const inputCheckboxes = computed(() => {
            const inputGroups = {
                core: { label: 'Inputs', name: 'core', inputs: inputList.core },
            };
            if (props.pro) {
                inputGroups.pro = {
                    label: 'Pro Inputs',
                    name: 'pro',
                    inputs: inputList.pro,
                };
            }
            if (props.addons) {
                inputGroups.addons = {
                    label: 'Add-ons',
                    name: 'addons',
                    inputs: inputList.addons,
                };
            }
            return inputGroups;
        });
        if (!props.schemas) {
            const coreInputPromises = inputList.core.map(async (schema) => {
                const response = await fetchInputSchema(schema);
                schemas[schema] = response;
            });
            promises.push(...coreInputPromises);
            if (props.forms) {
                const formsPromises = inputList.forms.map(async (schema) => {
                    const schemaName = `form/${schema}`;
                    const response = await fetchInputSchema(schemaName);
                    schemas[schemaName] = response;
                });
                promises.push(...formsPromises);
            }
            if (props.pro) {
                const proInputPromises = inputList.pro.map(async (schema) => {
                    const response = await fetchInputSchema(schema);
                    schemas[schema] = response;
                });
                promises.push(...proInputPromises);
            }
            if (props.addons) {
                const addonPromises = inputList.addons.map(async (schema) => {
                    const response = await fetchInputSchema(schema);
                    schemas[schema] = response;
                });
                promises.push(...addonPromises);
            }
        }
        else {
            const schemaPromises = props.schemas.map(async (schema) => {
                const response = await fetchInputSchema(`${schema}`);
                schemas[`${schema}`] = response;
            });
            promises.push(...schemaPromises);
        }
        // a plugin required for the "select all" checkbox functionality
        const selectAll = (node) => {
            let previousValue = [];
            let skip = false;
            if (node.props.type !== 'checkbox')
                return;
            node.on('created', () => {
                // if the only checked item is the "all" checkbox, check all
                const currentValue = node.value;
                if (Array.isArray(currentValue) &&
                    currentValue.length === 1 &&
                    currentValue[0] === 'all') {
                    node.input(node.props.options.map((option) => {
                        if (typeof option !== 'string')
                            return option.value;
                        return option;
                    }));
                }
                previousValue = Array.isArray(node.value) ? node.value : [];
            });
            node.on('commit', ({ payload }) => {
                if (skip) {
                    skip = false;
                    return;
                }
                if (!Array.isArray(payload))
                    return;
                const previousValueHadAll = previousValue.includes('all');
                const currentValueHasAll = payload.includes('all');
                // if "all" was checked, check all
                if (!previousValueHadAll && currentValueHasAll) {
                    const computedOptions = node.props.options.map((option) => {
                        if (typeof option !== 'string')
                            return option.value;
                        return option;
                    });
                    node.input(computedOptions);
                    previousValue = computedOptions;
                    return;
                }
                // if "all" was unchecked, uncheck all
                if (previousValueHadAll && !currentValueHasAll) {
                    node.input([]);
                    previousValue = [];
                    return;
                }
                const valueMinusAll = payload.filter((value) => value !== 'all');
                // uncheck "all" if we have less than all items checked
                if (valueMinusAll.length < node.props.options.length - 1 &&
                    currentValueHasAll) {
                    node.input(valueMinusAll);
                    previousValue = valueMinusAll;
                    skip = true;
                    return;
                }
                // re-check "all" if we manually check all other items
                if (valueMinusAll.length === node.props.options.length - 1 &&
                    !currentValueHasAll) {
                    const computedOptions = node.props.options.map((option) => {
                        if (typeof option !== 'string')
                            return option.value;
                        return option;
                    });
                    node.input(computedOptions);
                    previousValue = Array.isArray(node.value) ? node.value : [];
                    return;
                }
            });
        };
        // supporting schema functions for async input states
        const data = reactive({
            twClasses: classes,
            asyncLoader: async () => {
                // eslint-disable-next-line @typescript-eslint/no-empty-function
                return await new Promise(() => { });
            },
            paginatedLoader: async ({ page, hasNextPage, }) => {
                const base = (page - 1) * 10;
                hasNextPage();
                return Array.from({ length: 10 }, (_, i) => `Option ${base + i + 1}`);
            },
            formSubmitHandler: async (data) => {
                await new Promise((resolve) => setTimeout(resolve, 1000));
                alert('Form submitted (fake) — check console for data object');
                console.log('Form data:', data);
            },
            includes: (array, value) => {
                if (!Array.isArray(array))
                    return false;
                return array.includes(value);
            },
            checkboxPlugins: [selectAll],
            filters: [],
        });
        await Promise.all(promises);
        const inputKeys = Object.keys(schemas);
        // create friendly labels for use in tabs
        const formNames = inputKeys.map((key) => {
            if (key.startsWith('form/')) {
                switch (key) {
                    case 'form/tshirt':
                        return {
                            id: key,
                            name: 'Order Form',
                        };
                    default:
                        const name = key.replace('form/', '');
                        return {
                            id: key,
                            name: name.charAt(0).toUpperCase() + name.slice(1) + ' Form',
                        };
                }
            }
            return {
                id: key,
                name: '',
            };
        });
        const filteredFormNames = formNames.filter((form) => form.name !== '');
        const forms = inputKeys.filter((schema) => {
            return schema.startsWith('form/');
        });
        const inputs = inputKeys.filter((schema) => !schema.startsWith('form/'));
        const tabs = [];
        if (inputs.length) {
            tabs.push({
                id: 'kitchen-sink',
                name: 'Kitchen Sink',
            });
        }
        if (forms.length) {
            tabs.push(...filteredFormNames.sort((a, b) => (a.name > b.name ? 1 : -1)));
        }
        if (tabs.length) {
            activeTab.value = tabs[0].id;
        }
        // collection of all inputs to be rendered in the "kitchen sink" tab
        const kitchenSinkRenders = computed(() => {
            inputs.sort();
            const schemaDefinitions = inputs.reduce((schemaDefinitions, inputName) => {
                const schemaDefinition = schemas[inputName];
                schemaDefinitions.push({
                    $el: 'div',
                    if: '$includes($filters, "' + inputName + '")',
                    attrs: {
                        key: inputName,
                        class: '$twClasses.inputSection',
                        'data-type': inputName,
                    },
                    children: [
                        {
                            $el: 'h2',
                            attrs: {
                                class: '$twClasses.inputType',
                            },
                            children: inputName,
                        },
                        {
                            $el: 'div',
                            attrs: {
                                class: '$twClasses.specimenGroup',
                            },
                            children: [
                                ...(Array.isArray(schemaDefinition)
                                    ? schemaDefinition
                                    : [schemaDefinition]).map((specimen) => {
                                    return {
                                        $el: 'div',
                                        attrs: {
                                            class: '$twClasses.specimen',
                                        },
                                        children: [specimen],
                                    };
                                }),
                            ],
                        },
                    ],
                });
                return schemaDefinitions;
            }, []);
            return h(KeepAlive, {}, {
                default: () => {
                    return activeTab.value === 'kitchen-sink'
                        ? h(FormKitSchema, { schema: schemaDefinitions, data: data })
                        : null;
                },
            });
        });
        const formRenders = computed(() => {
            return filteredFormNames
                .map((form) => {
                const schemaDefinition = schemas[form.id];
                return h('div', {
                    key: form.id,
                }, activeTab.value === form.id
                    ? [
                        h('div', {
                            class: classes.formContainer,
                        }, [
                            h(FormKitSchema, {
                                schema: schemaDefinition[0],
                                data: data,
                            }),
                        ]),
                    ]
                    : '');
            })
                .filter((form) => form.children);
        });
        const tabBar = computed(() => {
            return h('div', {
                key: 'tab-bar',
                class: classes.tabs,
            }, tabs.map((tab) => {
                return h('span', {
                    class: classes.tab,
                    key: tab.id,
                    'data-tab': tab.id,
                    'data-active': activeTab.value === tab.id || undefined,
                    onClick: () => {
                        activeTab.value = tab.id;
                    },
                }, tab.name);
            }));
        });
        const filterCheckboxes = computed(() => {
            const createCheckboxSchema = (inputGroup) => {
                return {
                    $el: 'div',
                    attrs: {
                        class: '$twClasses.filterGroup',
                    },
                    children: [
                        {
                            $formkit: 'checkbox',
                            name: inputGroup.name,
                            label: inputGroup.label,
                            plugins: '$checkboxPlugins',
                            value: ['all'],
                            options: [
                                {
                                    label: 'All',
                                    value: 'all',
                                },
                                ...(Array.isArray(inputGroup.inputs) ? inputGroup.inputs : []),
                            ],
                        },
                    ],
                };
            };
            // render each set of checkboxes
            const filterSchema = h(FormKitSchema, {
                key: 'filter-checkboxes',
                data: data,
                schema: {
                    $formkit: 'group',
                    id: 'filter-checkboxes',
                    children: [
                        {
                            $el: 'div',
                            attrs: {
                                class: '$twClasses.filterContainer',
                            },
                            children: Object.keys(inputCheckboxes.value).map((key) => {
                                const inputGroup = inputCheckboxes.value[key];
                                return createCheckboxSchema(inputGroup);
                            }),
                        },
                    ],
                },
            });
            return h(KeepAlive, {}, {
                default: () => {
                    if (!(tabs.find((tab) => tab.id === 'kitchen-sink') &&
                        activeTab.value === 'kitchen-sink')) {
                        return null;
                    }
                    return filterSchema;
                },
            });
        });
        return () => {
            return h('div', {
                class: classes.container,
            }, [
                tabs.length > 1 ? tabBar.value : undefined,
                filterCheckboxes.value,
                ...formRenders.value,
                kitchenSinkRenders.value,
            ]);
        };
    },
});

/**
 * @internal
 */
const messages$1 = createSection('messages', () => ({
    $el: 'ul',
    if: '$fns.length($messages)',
}));
/**
 * @internal
 */
const message$1 = createSection('message', () => ({
    $el: 'li',
    for: ['message', '$messages'],
    attrs: {
        key: '$message.key',
        id: `$id + '-' + $message.key`,
        'data-message-type': '$message.type',
    },
}));
/**
 * The actual schema to render for the messages.
 */
const definition$1 = /* #__PURE__ */ messages$1(/* #__PURE__ */ message$1('$message.value'));
/**
 * Renders the messages for a parent node, or any node explicitly passed to it.
 * @public
 */
const FormKitMessages = /* #__PURE__ */ defineComponent({
    props: {
        node: {
            type: Object,
            required: false,
        },
        sectionsSchema: {
            type: Object,
            default: {},
        },
        defaultPosition: {
            type: [String, Boolean],
            default: false,
        },
    },
    setup(props, context) {
        const node = computed(() => {
            return props.node || inject(parentSymbol, undefined);
        });
        watch(node, () => {
            var _a;
            if (((_a = node.value) === null || _a === void 0 ? void 0 : _a.context) && !undefine(props.defaultPosition)) {
                node.value.context.defaultMessagePlacement = false;
            }
        }, { immediate: true });
        const schema = definition$1(props.sectionsSchema || {});
        const data = computed(() => {
            var _a, _b, _c, _d, _e, _f;
            return {
                messages: ((_b = (_a = node.value) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b.messages) || {},
                fns: ((_d = (_c = node.value) === null || _c === void 0 ? void 0 : _c.context) === null || _d === void 0 ? void 0 : _d.fns) || {},
                classes: ((_f = (_e = node.value) === null || _e === void 0 ? void 0 : _e.context) === null || _f === void 0 ? void 0 : _f.classes) || {},
            };
        });
        return () => {
            var _a;
            return ((_a = node.value) === null || _a === void 0 ? void 0 : _a.context)
                ? h(FormKitSchema, { schema, data: data.value }, { ...context.slots })
                : null;
        };
    },
});

/**
 * A composable to provide a given configuration to all children.
 * @param config - A FormKit configuration object or a function
 */
function useConfig(config) {
    const options = Object.assign({
        alias: 'FormKit',
        schemaAlias: 'FormKitSchema',
    }, typeof config === 'function' ? config() : config);
    /**
     * The root configuration options.
     */
    const rootConfig = createConfig(options.config || {});
    /**
     * We dont want to explicitly provide any "config" options, only a root
     * config option — so here we override the existing config options.
     */
    options.config = { rootConfig };
    /**
     * Provide the config to children.
     */
    provide(optionsSymbol, options);
    /**
     * Provide the root config to the children.
     */
    provide(configSymbol, rootConfig);
    /**
     * Register the FormKit component globally.
     */
    if (typeof window !== 'undefined') {
        globalThis.__FORMKIT_CONFIGS__ = (globalThis.__FORMKIT_CONFIGS__ || []).concat([rootConfig]);
    }
}
/**
 * The FormKitProvider component provides the FormKit config to the children.
 *
 * @public
 */
const FormKitProvider = /* #__PURE__ */ defineComponent(function FormKitProvider(props, { slots, attrs }) {
    const options = {};
    if (props.config) {
        useConfig(props.config);
    }
    return () => slots.default
        ? slots.default(options).map((vnode) => {
            return h(vnode, {
                ...attrs,
                ...vnode.props,
            });
        })
        : null;
}, { props: ['config'], name: 'FormKitProvider', inheritAttrs: false });
/**
 * The FormKitConfigLoader is an async component (meaning it needs a parent or
 * grandparent Suspense component to render) that loads the FormKit config and
 * provides it to the children.
 *
 * @internal
 */
const FormKitConfigLoader = /* #__PURE__ */ defineComponent(async function FormKitConfigLoader(props, context) {
    var _a;
    let config = {};
    if (props.configFile) {
        const configFile = await import(
        /*@__formkit.config.ts__*/ /* @vite-ignore */ /* webpackIgnore: true */ props.configFile);
        config = 'default' in configFile ? configFile.default : configFile;
    }
    // Ensure this a factory function for runtimeConfig in nuxt.
    if (typeof config === 'function') {
        config = config();
    }
    /* @__default-config__ */
    const useDefaultConfig = (_a = props.defaultConfig) !== null && _a !== void 0 ? _a : true;
    if (useDefaultConfig) {
        const { defaultConfig } = await Promise.resolve().then(function () { return defaultConfig$1; });
        config = /* @__PURE__ */ defaultConfig(config);
    }
    /* @__default-config__ */
    return () => h(FormKitProvider, { ...context.attrs, config }, context.slots);
}, {
    props: ['defaultConfig', 'configFile'],
    inheritAttrs: false,
});
/**
 * The FormKitLazyProvider component performs 2 HOC functions:
 *
 * 1. It checks if a FormKit config has already been provided, if it has it will
 *   render the children immediately.
 * 2. If a config has not been provided, it will render a Suspense component
 *    which will render the children once the config has been loaded by using
 *    the FormKitConfigLoader component.
 *
 * @public
 */
const FormKitLazyProvider = /* #__PURE__ */ defineComponent(function FormKitLazyProvider(props, context) {
    const config = inject(optionsSymbol, null);
    /* pass any attrs through */
    const passthru = (vnode) => {
        return h(vnode, {
            ...context.attrs,
            ...vnode.props,
        });
    };
    if (config) {
        // If there is already a config provided, render the children immediately.
        return () => { var _a; return ((_a = context.slots) === null || _a === void 0 ? void 0 : _a.default) ? context.slots.default().map(passthru) : null; };
    }
    const instance = getCurrentInstance();
    if (instance.suspense) {
        // If there is a suspense boundary already in place, we can render the
        // config loader without another suspense boundary.
        return () => h(FormKitConfigLoader, props, {
            default: () => {
                var _a;
                return ((_a = context.slots) === null || _a === void 0 ? void 0 : _a.default)
                    ? context.slots.default().map(passthru)
                    : null;
            },
        });
    }
    // If there is no suspense boundary, and no config, we render the suspense
    // boundary and the config loader.
    return () => h(Suspense, null, {
        ...context.slots,
        default: () => h(FormKitConfigLoader, { ...context.attrs, ...props }, context.slots),
    });
}, {
    props: ['defaultConfig', 'configFile'],
    inheritAttrs: false,
});

const summary = createSection('summary', () => ({
    $el: 'div',
    attrs: {
        'aria-live': 'polite',
    },
}));
const summaryInner = createSection('summaryInner', () => ({
    $el: 'div',
    if: '$summaries.length && $showSummaries',
}));
/**
 * @internal
 */
const messages = createSection('messages', () => ({
    $el: 'ul',
    if: '$summaries.length && $showSummaries',
}));
/**
 * @internal
 */
const message = createSection('message', () => ({
    $el: 'li',
    for: ['summary', '$summaries'],
    attrs: {
        key: '$summary.key',
        'data-message-type': '$summary.type',
    },
}));
const summaryHeader = createSection('summaryHeader', () => ({
    $el: 'h2',
    attrs: {
        id: '$id',
    },
}));
const messageLink = createSection('messageLink', () => ({
    $el: 'a',
    attrs: {
        id: '$summary.key',
        href: '$: "#" + $summary.id',
        onClick: '$jumpLink',
    },
}));
/**
 * The actual schema to render for the messages.
 */
const definition = /* #__PURE__ */ summary(/* #__PURE__ */ summaryInner(/* #__PURE__ */ summaryHeader('$summaryHeader'), /* #__PURE__ */ messages(/* #__PURE__ */ message(/* #__PURE__ */ messageLink('$summary.message')))));
/**
 * Renders the messages for a parent node, or any node explicitly passed to it.
 * @public
 */
const FormKitSummary = /* #__PURE__ */ defineComponent({
    props: {
        node: {
            type: Object,
            required: false,
        },
        forceShow: {
            type: Boolean,
            default: false,
        },
        sectionsSchema: {
            type: Object,
            default: {},
        },
    },
    emits: {
        /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
        show: (_summaries) => true,
    },
    setup(props, context) {
        var _a, _b;
        const id = `summary-${token()}`;
        const node = computed(() => {
            return props.node || inject(parentSymbol, undefined);
        });
        if (!node)
            throw new Error('FormKitSummary must have a FormKit parent or use the node prop.');
        const summaryContexts = ref([]);
        const showSummaries = ref(false);
        const summaries = computed(() => {
            const summarizedMessages = [];
            summaryContexts.value.forEach((context) => {
                for (const idx in context.messages) {
                    const message = context.messages[idx];
                    if (typeof message.value !== 'string')
                        continue;
                    summarizedMessages.push({
                        message: message.value,
                        id: context.id,
                        key: `${context.id}-${message.key}`,
                        type: message.type,
                    });
                }
            });
            return summarizedMessages;
        });
        const addContexts = () => {
            var _a;
            summaryContexts.value = [];
            (_a = node.value) === null || _a === void 0 ? void 0 : _a.walk((child) => child.context && summaryContexts.value.push(child.context));
        };
        (_a = node.value) === null || _a === void 0 ? void 0 : _a.on('submit-raw', async () => {
            var _a, _b;
            addContexts();
            if (summaries.value.length === 0)
                return;
            context.emit('show', summaries.value);
            showSummaries.value = true;
            await nextTick();
            if (typeof window !== 'undefined') {
                (_a = document.getElementById(id)) === null || _a === void 0 ? void 0 : _a.scrollIntoView({ behavior: 'smooth' });
                if (summaries.value[0]) {
                    (_b = document.getElementById(summaries.value[0].key)) === null || _b === void 0 ? void 0 : _b.focus();
                }
            }
        });
        (_b = node.value) === null || _b === void 0 ? void 0 : _b.on('child', addContexts);
        function jumpLink(e) {
            var _a, _b, _c;
            if (e.target instanceof HTMLAnchorElement) {
                e.preventDefault();
                const id = (_a = e.target.getAttribute('href')) === null || _a === void 0 ? void 0 : _a.substring(1);
                if (id) {
                    (_b = document.getElementById(id)) === null || _b === void 0 ? void 0 : _b.scrollIntoView({ behavior: 'smooth' });
                    (_c = document.getElementById(id)) === null || _c === void 0 ? void 0 : _c.focus();
                }
            }
        }
        localize('summaryHeader', 'There were errors in your form.')(node.value);
        const schema = definition(props.sectionsSchema || {});
        const data = computed(() => {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            return {
                id,
                fns: ((_b = (_a = node.value) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b.fns) || {},
                classes: ((_d = (_c = node.value) === null || _c === void 0 ? void 0 : _c.context) === null || _d === void 0 ? void 0 : _d.classes) || {},
                summaries: summaries.value,
                showSummaries: props.forceShow || showSummaries.value,
                summaryHeader: ((_h = (_g = (_f = (_e = node.value) === null || _e === void 0 ? void 0 : _e.context) === null || _f === void 0 ? void 0 : _f.ui) === null || _g === void 0 ? void 0 : _g.summaryHeader) === null || _h === void 0 ? void 0 : _h.value) || '',
                jumpLink,
            };
        });
        return () => {
            var _a;
            return ((_a = node.value) === null || _a === void 0 ? void 0 : _a.context)
                ? h(FormKitSchema, { schema, data: data.value }, { ...context.slots })
                : null;
        };
    },
});

/**
 * A plugin that creates Vue-specific context object on each given node.
 *
 * @param node - FormKitNode to create the context on.
 *
 * @public
 */
const vueBindings = function vueBindings(node) {
    /**
     * Start a validity counter on all blocking messages.
     */
    node.ledger.count('blocking', (m) => m.blocking);
    const isValid = ref(!node.ledger.value('blocking'));
    /**
     * Start an error message counter.
     */
    node.ledger.count('errors', (m) => m.type === 'error');
    const hasErrors = ref(!!node.ledger.value('errors'));
    /**
     * Keep track of the first time a Vue tick cycle has passed.
     */
    let hasTicked = false;
    nextTick(() => {
        hasTicked = true;
    });
    /**
     * All messages with the visibility state set to true.
     */
    const availableMessages = reactive(node.store.reduce((store, message) => {
        if (message.visible) {
            store[message.key] = message;
        }
        return store;
    }, {}));
    /**
     * A flag that determines when validation messages should be displayed.
     */
    const validationVisibility = ref(node.props.validationVisibility ||
        (node.props.type === 'checkbox' ? 'dirty' : 'blur'));
    node.on('prop:validationVisibility', ({ payload }) => {
        validationVisibility.value = payload;
    });
    /**
     * Keep track of if this input has ever shown validation errors.
     */
    const hasShownErrors = ref(validationVisibility.value === 'live');
    /**
     * If the input is required or not, this is the only validation rule that
     * needs to be explicitly called out since it powers the aria-required attr.
     */
    const isRequired = ref(false);
    const checkForRequired = (parsedRules) => {
        isRequired.value = (parsedRules !== null && parsedRules !== void 0 ? parsedRules : []).some((rule) => rule.name === 'required');
    };
    checkForRequired(node.props.parsedRules);
    node.on('prop:parsedRules', ({ payload }) => checkForRequired(payload));
    /**
     * An array of unique identifiers that should only be used for iterating
     * inside a synced list.
     */
    const items = ref(node.children.map((child) => child.uid));
    /**
     * The current visibility state of validation messages.
     */
    const validationVisible = computed(() => {
        if (!context.state)
            return false;
        if (context.state.submitted)
            return true;
        if (!hasShownErrors.value && !context.state.settled) {
            return false;
        }
        switch (validationVisibility.value) {
            case 'live':
                return true;
            case 'blur':
                return context.state.blurred;
            case 'dirty':
                return context.state.dirty;
            default:
                return false;
        }
    });
    /**
     * Determines if the input should be considered "complete".
     */
    const isComplete = computed(() => {
        return context && hasValidation.value
            ? isValid.value && !hasErrors.value
            : context.state.dirty && !empty(context.value);
    });
    /**
     * If the input has validation rules or not.
     */
    const hasValidation = ref(Array.isArray(node.props.parsedRules) && node.props.parsedRules.length > 0);
    node.on('prop:parsedRules', ({ payload: rules }) => {
        hasValidation.value = Array.isArray(rules) && rules.length > 0;
    });
    /**
     * All messages that are currently on display to an end user. This changes
     * based on the current message type visibility, like errorVisibility.
     */
    const messages = computed(() => {
        const visibleMessages = {};
        for (const key in availableMessages) {
            const message = availableMessages[key];
            if (message.type !== 'validation' || validationVisible.value) {
                visibleMessages[key] = message;
            }
        }
        return visibleMessages;
    });
    /**
     * UI Messages.
     */
    const ui = reactive(node.store.reduce((messages, message) => {
        if (message.type === 'ui' && message.visible)
            messages[message.key] = message;
        return messages;
    }, {}));
    /**
     * This is the reactive data object that is provided to all schemas and
     * forms. It is a subset of data in the core node object.
     */
    const cachedClasses = reactive({});
    const classes = new Proxy(cachedClasses, {
        get(...args) {
            const [target, property] = args;
            let className = Reflect.get(...args);
            if (!className && typeof property === 'string') {
                if (!has(target, property) && !property.startsWith('__v')) {
                    const observedNode = createObserver(node);
                    observedNode.watch((node) => {
                        const rootClasses = typeof node.config.rootClasses === 'function'
                            ? node.config.rootClasses(property, node)
                            : {};
                        const globalConfigClasses = node.config.classes
                            ? createClasses(property, node, node.config.classes[property])
                            : {};
                        const classesPropClasses = createClasses(property, node, node.props[`_${property}Class`]);
                        const sectionPropClasses = createClasses(property, node, node.props[`${property}Class`]);
                        className = generateClassList(node, property, rootClasses, globalConfigClasses, classesPropClasses, sectionPropClasses);
                        target[property] = className !== null && className !== void 0 ? className : '';
                    });
                }
            }
            return className;
        },
    });
    node.on('prop:rootClasses', () => {
        const keys = Object.keys(cachedClasses);
        for (const key of keys) {
            delete cachedClasses[key];
        }
    });
    const describedBy = computed(() => {
        const describers = [];
        if (context.help) {
            describers.push(`help-${node.props.id}`);
        }
        for (const key in messages.value) {
            describers.push(`${node.props.id}-${key}`);
        }
        return describers.length ? describers.join(' ') : undefined;
    });
    const value = ref(node.value);
    const _value = ref(node.value);
    const context = reactive({
        _value,
        attrs: node.props.attrs,
        disabled: node.props.disabled,
        describedBy,
        fns: {
            length: (obj) => Object.keys(obj).length,
            number: (value) => Number(value),
            string: (value) => String(value),
            json: (value) => JSON.stringify(value),
            eq,
        },
        handlers: {
            blur: (e) => {
                if (!node)
                    return;
                node.store.set(createMessage({ key: 'blurred', visible: false, value: true }));
                if (typeof node.props.attrs.onBlur === 'function') {
                    node.props.attrs.onBlur(e);
                }
            },
            touch: () => {
                var _a;
                const doCompare = context.dirtyBehavior === 'compare';
                if (((_a = node.store.dirty) === null || _a === void 0 ? void 0 : _a.value) && !doCompare)
                    return;
                const isDirty = !eq(node.props._init, node._value);
                if (!isDirty && !doCompare)
                    return;
                node.store.set(createMessage({ key: 'dirty', visible: false, value: isDirty }));
            },
            DOMInput: (e) => {
                node.input(e.target.value);
                node.emit('dom-input-event', e);
            },
        },
        help: node.props.help,
        id: node.props.id,
        items,
        label: node.props.label,
        messages,
        node: markRaw(node),
        options: node.props.options,
        defaultMessagePlacement: true,
        slots: node.props.__slots,
        state: {
            blurred: false,
            complete: isComplete,
            dirty: false,
            empty: empty(value),
            submitted: false,
            settled: node.isSettled,
            valid: isValid,
            errors: hasErrors,
            rules: hasValidation,
            validationVisible,
            required: isRequired,
        },
        type: node.props.type,
        family: node.props.family,
        ui,
        value,
        classes,
    });
    /**
     * Ensure the context object is properly configured after booting up.
     */
    node.on('created', () => {
        if (!eq(context.value, node.value)) {
            _value.value = node.value;
            value.value = node.value;
            triggerRef(value);
            triggerRef(_value);
        }
        (async () => {
            await node.settled;
            if (node)
                node.props._init = cloneAny(node.value);
        })();
    });
    /**
     * Sets the settled state.
     */
    node.on('settled', ({ payload: isSettled }) => {
        context.state.settled = isSettled;
    });
    /**
     * Observes node.props properties explicitly and updates them in the context
     * object.
     * @param observe - Props to observe and register as context data.
     */
    function observeProps(observe) {
        observe.forEach((prop) => {
            prop = camel(prop);
            if (!has(context, prop)) {
                context[prop] = node.props[prop];
            }
            node.on(`prop:${prop}`, ({ payload }) => {
                context[prop] = payload;
            });
        });
    }
    /**
     * We use a node observer to individually observe node props.
     */
    const rootProps = () => {
        const props = [
            '__root',
            'help',
            'label',
            'disabled',
            'options',
            'type',
            'attrs',
            'preserve',
            'preserveErrors',
            'id',
            'dirtyBehavior',
        ];
        const iconPattern = /^[a-zA-Z-]+(?:-icon|Icon)$/;
        const matchingProps = Object.keys(node.props).filter((prop) => {
            return iconPattern.test(prop);
        });
        return props.concat(matchingProps);
    };
    observeProps(rootProps());
    /**
     * Once the input is defined, deal with it.
     * @param definition - Type definition.
     */
    function definedAs(definition) {
        if (definition.props)
            observeProps(definition.props);
    }
    node.props.definition && definedAs(node.props.definition);
    /**
     * When new props are added to the core node as "props" (ie not attrs) then
     * we automatically need to start tracking them here.
     */
    node.on('added-props', ({ payload }) => observeProps(payload));
    /**
     * Watch for input events from core.
     */
    node.on('input', ({ payload }) => {
        if (node.type !== 'input' && !isRef(payload) && !isReactive(payload)) {
            _value.value = shallowClone(payload);
        }
        else {
            _value.value = payload;
            triggerRef(_value);
        }
    });
    /**
     * Model updates from core. This is the raw value and should emitted as a
     * model update even if the value did not update internally. Why? Because
     * the model that created this event may have not be the same value as our
     * internal value.
     *
     * See test: "emits a modelUpdated event even when the value results in the
     * same value"
     */
    node.on('commitRaw', ({ payload }) => {
        if (node.type !== 'input' && !isRef(payload) && !isReactive(payload)) {
            value.value = _value.value = shallowClone(payload);
        }
        else {
            value.value = _value.value = payload;
            triggerRef(value);
        }
        node.emit('modelUpdated');
    });
    /**
     * Watch for input commits from core.
     */
    node.on('commit', ({ payload }) => {
        // The input is dirty after a value has been input by a user
        if ((!context.state.dirty || context.dirtyBehavior === 'compare') &&
            node.isCreated &&
            hasTicked) {
            context.handlers.touch();
        }
        if (isComplete &&
            node.type === 'input' &&
            hasErrors.value &&
            !undefine(node.props.preserveErrors)) {
            node.store.filter((message) => { var _a; return !(message.type === 'error' && ((_a = message.meta) === null || _a === void 0 ? void 0 : _a.autoClear) === true); });
        }
        if (node.type === 'list' && node.sync) {
            items.value = node.children.map((child) => child.uid);
        }
        context.state.empty = empty(payload);
    });
    /**
     * Update the local state in response to messages.
     * @param message - A formkit message
     */
    const updateState = async (message) => {
        if (message.type === 'ui' &&
            message.visible &&
            !message.meta.showAsMessage) {
            ui[message.key] = message;
        }
        else if (message.visible) {
            availableMessages[message.key] = message;
        }
        else if (message.type === 'state') {
            // await node.settled
            context.state[message.key] = !!message.value;
        }
    };
    /**
     * Listen to message events and modify the local message data values.
     */
    node.on('message-added', (e) => updateState(e.payload));
    node.on('message-updated', (e) => updateState(e.payload));
    node.on('message-removed', ({ payload: message }) => {
        delete ui[message.key];
        delete availableMessages[message.key];
        delete context.state[message.key];
    });
    node.on('settled:blocking', () => {
        isValid.value = true;
    });
    node.on('unsettled:blocking', () => {
        isValid.value = false;
    });
    node.on('settled:errors', () => {
        hasErrors.value = false;
    });
    node.on('unsettled:errors', () => {
        hasErrors.value = true;
    });
    /**
     * Watch the validation visible prop and set the hasShownErrors state.
     */
    watch(validationVisible, (value) => {
        if (value) {
            hasShownErrors.value = true;
        }
    });
    node.context = context;
    // The context is complete
    node.emit('context', node, false);
    node.on('destroyed', () => {
        node.context = undefined;
        /* @ts-ignore */ // eslint-disable-line
        node = null;
    });
};

/**
 * Default configuration options. Includes all validation rules,
 * en i18n messages.
 *
 * @public
 */
const defaultConfig = (options = {}) => {
    register();
    const { rules = {}, locales = {}, inputs: inputs$1 = {}, messages = {}, locale = undefined, theme = undefined, iconLoaderUrl = undefined, iconLoader = undefined, icons = {}, ...nodeOptions } = options;
    /**
     * The default configuration includes the validation plugin,
     * with all core-available validation rules.
     */
    const validation = createValidationPlugin({
        ...defaultRules,
        ...(rules || {}),
    });
    /**
     * Includes the i18n plugin with only the english language
     * messages.
     */
    const i18n = createI18nPlugin(extend({ en, ...(locales || {}) }, messages));
    /**
     * Create the library of inputs that are generally available. This default
     * config imports all "native" inputs by default, but
     */
    const library = createLibraryPlugin(inputs, inputs$1);
    /**
     * Create the theme plugin for the user provided theme
     */
    const themePlugin = createThemePlugin(theme, icons, iconLoaderUrl, iconLoader);
    return extend({
        plugins: [library, themePlugin, vueBindings, i18n, validation],
        ...(!locale ? {} : { config: { locale } }),
    }, nodeOptions || {}, true);
};

var defaultConfig$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    defaultConfig: defaultConfig
});

/**
 * Renders an icon using the current IconLoader set at the root FormKit config
 *
 * @public
 */
const FormKitIcon = /* #__PURE__ */ defineComponent({
    name: 'FormKitIcon',
    props: {
        icon: {
            type: String,
            default: '',
        },
        iconLoader: {
            type: Function,
            default: null,
        },
        iconLoaderUrl: {
            type: Function,
            default: null,
        },
    },
    setup(props) {
        var _a, _b;
        const icon = ref(undefined);
        const config = inject(optionsSymbol, {});
        const parent = inject(parentSymbol, null);
        let iconHandler = undefined;
        function loadIcon() {
            if (!iconHandler || typeof iconHandler !== 'function')
                return;
            const iconOrPromise = iconHandler(props.icon);
            if (iconOrPromise instanceof Promise) {
                iconOrPromise.then((iconValue) => {
                    icon.value = iconValue;
                });
            }
            else {
                icon.value = iconOrPromise;
            }
        }
        if (props.iconLoader && typeof props.iconLoader === 'function') {
            // if we have a locally supplied loader, then use it
            iconHandler = createIconHandler(props.iconLoader);
        }
        else if (parent && ((_a = parent.props) === null || _a === void 0 ? void 0 : _a.iconLoader)) {
            // otherwise try to inherit from a parent
            iconHandler = createIconHandler(parent.props.iconLoader);
        }
        else if (props.iconLoaderUrl &&
            typeof props.iconLoaderUrl === 'function') {
            iconHandler = createIconHandler(iconHandler, props.iconLoaderUrl);
        }
        else {
            // grab our iconHandler from the global config
            const iconPlugin = (_b = config === null || config === void 0 ? void 0 : config.plugins) === null || _b === void 0 ? void 0 : _b.find((plugin) => {
                return (typeof plugin
                    .iconHandler === 'function');
            });
            if (iconPlugin) {
                iconHandler = iconPlugin.iconHandler;
            }
        }
        watch(() => props.icon, () => {
            loadIcon();
        }, { immediate: true });
        return () => {
            if (props.icon && icon.value) {
                return h('span', {
                    class: 'formkit-icon',
                    innerHTML: icon.value,
                });
            }
            return null;
        };
    },
});

export { formkitComponent as FormKit, FormKitIcon, FormKitKitchenSink, FormKitLazyProvider, FormKitMessages, FormKitProvider, FormKitRoot, FormKitSchema, FormKitSummary, vueBindings as bindings, configSymbol, createInput, defaultConfig, defineFormKitConfig, getCurrentSchemaNode, onSSRComplete, optionsSymbol, parentSymbol, plugin, rootSymbol, ssrComplete, useConfig, useInput };
